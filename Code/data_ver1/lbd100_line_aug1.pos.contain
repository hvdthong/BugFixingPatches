jbd2 use write_sync in journal checkpoint in journal checkpoint we write the buffer and wait for its finish but in cfq the async queue has a very low priority and in our test if there are too many sync queues and every queue is filled up with requests the write request will be delayed for quite a long time and all the tasks which are waiting for journal space will end with errors like info task blocked for more than __number__ seconds echo __number__ disables this message attr_set d __address__ __number__ __number__ __number__ __number__ __address__ __number__ __address__ __address__ __address__ __address__ __address__ __address__ __address__ __address__ __address__ __number__ call trace __address__ __address__ __address__ __address__ jbd2 __address__ jbd2 __address__ __address__ ext4 __address__ __address__ __address__ jbd2 __address__ jbd2 __address__ __address__ jbd2 __address__ ext4 __address__ ext4 __address__ ext4 __address__ __address__ __address__ __address__ __address__ __address__ __address__ so this patch tries to use write_sync in __flush_batch so that the request will be moved into sync queue and handled by cfq timely we also use the new plug sot that all the write_sync requests can be given as a whole when we unplug it	fs jbd2 checkpoint Ttcons TIdent TIdent TPtVirg TIdent TOPar & TIdent TCPar TPtVirg TIdent TOPar TIdent TPtrOp TIdent TOCro TIdent TCCro TComma TIdent TCPar TPtVirg TIdent TOPar & TIdent TCPar TPtVirg TIdent TOPar TIdent TPtrOp TIdent TOCro TIdent TCCro TComma TIdent TCPar TPtVirg
staging wilc1000 restore wilc_spi_dev variable a recent change to wilc1000 accidentally deleted an important variable so we now get a build error when the spi mode is selected error wilc_spi_dev undefined this partially reverts the broken commit to put the variable back	drivers staging wilc1000 linux_wlan_spi Ttcons TIdent * TIdent TPtVirg
media nuvoton-cir fix setting ioport base address at least on zotac ci321 acpi provides an ioport range for the wake up part but accessing these ioports has no effect instead the ioport base address is set to another value already in my case and accessing this ioport range works therefore set a new ioport base address only if the current ioport base address is __number__ register reset default the need to use the existing base address instead of trying to set an own one doesnt seem to be limited to this specific device as other drivers like do it the same way this change was successfully tested on the mentioned device and the change should be generic enough to not break the driver for other chips however due to lack of appropriate hardware i wasnt able to test this version	drivers media rc nuvoton-cir Tvis Ttype TIdent TOPar Ttcons TIdent * TIdent TComma Tsign Ttype * TIdent TCPar Tsign Ttype TIdent TPtVirg TIdent = TIdent TOPar TIdent TComma TIdent TCPar << TInt TPtVirg TIdent |= TIdent TOPar TIdent TComma TIdent TCPar TPtVirg Tkwd TOPar TIdent TCPar * TIdent = TIdent TPtVirg TIdent TOPar TIdent TComma * TIdent >> TInt TComma TIdent TCPar TPtVirg TIdent TOPar TIdent TComma * TIdent & TInt TComma TIdent TCPar TPtVirg TIdent TOPar TIdent TComma & TIdent TPtrOp TIdent TCPar TPtVirg TIdent TOPar TIdent TComma TIdent TPtrOp TIdent >> TInt TComma TIdent TCPar TPtVirg TIdent TOPar TIdent TComma TIdent TPtrOp TIdent & TInt TComma TIdent TCPar TPtVirg TIdent TOPar TIdent TComma & TIdent TPtrOp TIdent TCPar TPtVirg TIdent TOPar TIdent TComma TIdent TPtrOp TIdent >> TInt TComma TIdent TCPar TPtVirg TIdent TOPar TIdent TComma TIdent TPtrOp TIdent & TInt TComma TIdent TCPar TPtVirg
tracing function fix trace header to follow context-info option the header display of function tracer does not follow the context-info option so field names are displayed even if this option is off added check for trace_iter_context_info trace_flags with following commands echo function echo __number__ cat trace this is what it looked like before tracer function task-pid timestamp function add_preempt_count rcu_note_context_switch this is what it looks like now tracer function _raw_spin_unlock_irqrestore link	kernel trace trace Tkwd TOPar TBang TOPar TIdent & TIdent TCPar TCPar Tkwd TPtVirg
ipv6 drop metadata dst in ip6_route_input the fix in commit is incomplete as now ip6_route_input can be called with non-null dst if its a metadata dst and the reference is leaked drop the reference	net ipv6 route TIdent TOPar TIdent TCPar TPtVirg
nvmx reset rflags register cache during nested vmentry during nested vmentry into vm86 mode a vcpu state is found to be incorrect because rflags does not have vm flag set since it is read from the cache and has l1s value instead of l2s if l0 kvm tries to emulate it but emulation does not work for nvmx and it never should happen anyway fix that by using vmx_set_rflags to set rflags during nested vmentry which takes care of updating register cache	arch x86 kvm vmx TIdent TOPar TIdent TComma TIdent TPtrOp TIdent TCPar TPtVirg TIdent TOPar TIdent TComma TIdent TPtrOp TIdent TCPar TPtVirg
asoc wm5102 correct supported channels on trace compressed dai the audio trace firmware on wm5102 only supports __number__ channels correct the dai driver structure to reflect this	sound soc codecs wm5102 Tvis Ttcons TIdent TIdent TOCro TCCro = TOBrace TOBrace TDot TIdent = TString TComma TDot TIdent = TInt TComma TDot TIdent = TIdent TComma TDot TIdent = TOBrace TDot TIdent = TString TComma TDot TIdent = TInt TComma TDot TIdent = TInt TComma TDot TIdent = TIdent TComma TDot TIdent = TIdent TComma TCBrace TComma TDot TIdent = TOBrace TDot TIdent = TString TComma TDot TIdent = TInt TComma TDot TIdent = TInt TComma TDot TIdent = TIdent TComma TDot TIdent = TIdent TComma TCBrace TComma TDot TIdent = & TIdent TComma TDot TIdent = TInt TComma TDot TIdent = TInt TComma TCBrace TComma TOBrace TDot TIdent = TString TComma TDot TIdent = TInt TComma TDot TIdent = TIdent TComma TDot TIdent = TOBrace TDot TIdent = TString TComma TDot TIdent = TInt TComma TDot TIdent = TInt TComma TDot TIdent = TIdent TComma TDot TIdent = TIdent TComma TCBrace TComma TDot TIdent = TOBrace TDot TIdent = TString TComma TDot TIdent = TInt TComma TDot TIdent = TInt TComma TDot TIdent = TIdent TComma TDot TIdent = TIdent TComma TCBrace TComma TDot TIdent = & TIdent TComma TDot TIdent = TInt TComma TDot TIdent = TInt TComma TCBrace TComma TOBrace TDot TIdent = TString TComma TDot TIdent = TInt TComma TDot TIdent = TIdent TComma TDot TIdent = TOBrace TDot TIdent = TString TComma TDot TIdent = TInt TComma TDot TIdent = TInt TComma TDot TIdent = TIdent TComma TDot TIdent = TIdent TComma TCBrace TComma TDot TIdent = TOBrace TDot TIdent = TString TComma TDot TIdent = TInt TComma TDot TIdent = TInt TComma TDot TIdent = TIdent TComma TDot TIdent = TIdent TComma TCBrace TComma TDot TIdent = & TIdent TComma TDot TIdent = TInt TComma TDot TIdent = TInt TComma TCBrace TComma TOBrace TDot TIdent = TString TComma TDot TIdent = TInt TComma TDot TIdent = TOBrace TDot TIdent = TString TComma TDot TIdent = TInt TComma TDot TIdent = TInt TComma TDot TIdent = TIdent TComma TDot TIdent = TIdent TComma TCBrace TComma TDot TIdent = TOBrace TDot TIdent = TString TComma TDot TIdent = TInt TComma TDot TIdent = TInt TComma TDot TIdent = TIdent TComma TDot TIdent = TIdent TComma TCBrace TComma TDot TIdent = & TIdent TComma TCBrace TComma TOBrace TDot TIdent = TString TComma TDot TIdent = TInt TComma TDot TIdent = TOBrace TDot TIdent = TString TComma TDot TIdent = TInt TComma TDot TIdent = TInt TComma TDot TIdent = TIdent TComma TDot TIdent = TIdent TComma TCBrace TComma TDot TIdent = TOBrace TDot TIdent = TString TComma TDot TIdent = TInt TComma TDot TIdent = TInt TComma TDot TIdent = TIdent TComma TDot TIdent = TIdent TComma TCBrace TComma TDot TIdent = & TIdent TComma TCBrace TComma TOBrace TDot TIdent = TString TComma TDot TIdent = TInt TComma TDot TIdent = TOBrace TDot TIdent = TString TComma TDot TIdent = TInt TComma TDot TIdent = TInt TComma TDot TIdent = TIdent TComma TDot TIdent = TIdent TComma TCBrace TComma TDot TIdent = TOBrace TDot TIdent = TString TComma TDot TIdent = TInt TComma TDot TIdent = TInt TComma TDot TIdent = TIdent TComma TDot TIdent = TIdent TComma TCBrace TComma TDot TIdent = & TIdent TComma TCBrace TComma TOBrace TDot TIdent = TString TComma TDot TIdent = TOBrace TDot TIdent = TString TComma TDot TIdent = TInt TComma TDot TIdent = TInt TComma TDot TIdent = TIdent TComma TDot TIdent = TIdent TComma TCBrace TComma TDot TIdent = TIdent TComma TCBrace TComma TOBrace TDot TIdent = TString TComma TDot TIdent = TOBrace TDot TIdent = TString TComma TDot TIdent = TInt TComma TDot TIdent = TInt TComma TDot TIdent = TIdent TComma TDot TIdent = TIdent TComma TCBrace TComma TCBrace TComma TCBrace TPtVirg Tvis Ttcons TIdent TIdent TOCro TCCro = TOBrace TOBrace TDot TIdent = TString TComma TDot TIdent = TInt TComma TDot TIdent = TIdent TComma TDot TIdent = TOBrace TDot TIdent = TString TComma TDot TIdent = TInt TComma TDot TIdent = TInt TComma TDot TIdent = TIdent TComma TDot TIdent = TIdent TComma TCBrace TComma TDot TIdent = TOBrace TDot TIdent = TString TComma TDot TIdent = TInt TComma TDot TIdent = TInt TComma TDot TIdent = TIdent TComma TDot TIdent = TIdent TComma TCBrace TComma TDot TIdent = & TIdent TComma TDot TIdent = TInt TComma TDot TIdent = TInt TComma TCBrace TComma TOBrace TDot TIdent = TString TComma TDot TIdent = TInt TComma TDot TIdent = TIdent TComma TDot TIdent = TOBrace TDot TIdent = TString TComma TDot TIdent = TInt TComma TDot TIdent = TInt TComma TDot TIdent = TIdent TComma TDot TIdent = TIdent TComma TCBrace TComma TDot TIdent = TOBrace TDot TIdent = TString TComma TDot TIdent = TInt TComma TDot TIdent = TInt TComma TDot TIdent = TIdent TComma TDot TIdent = TIdent TComma TCBrace TComma TDot TIdent = & TIdent TComma TDot TIdent = TInt TComma TDot TIdent = TInt TComma TCBrace TComma TOBrace TDot TIdent = TString TComma TDot TIdent = TInt TComma TDot TIdent = TIdent TComma TDot TIdent = TOBrace TDot TIdent = TString TComma TDot TIdent = TInt TComma TDot TIdent = TInt TComma TDot TIdent = TIdent TComma TDot TIdent = TIdent TComma TCBrace TComma TDot TIdent = TOBrace TDot TIdent = TString TComma TDot TIdent = TInt TComma TDot TIdent = TInt TComma TDot TIdent = TIdent TComma TDot TIdent = TIdent TComma TCBrace TComma TDot TIdent = & TIdent TComma TDot TIdent = TInt TComma TDot TIdent = TInt TComma TCBrace TComma TOBrace TDot TIdent = TString TComma TDot TIdent = TInt TComma TDot TIdent = TOBrace TDot TIdent = TString TComma TDot TIdent = TInt TComma TDot TIdent = TInt TComma TDot TIdent = TIdent TComma TDot TIdent = TIdent TComma TCBrace TComma TDot TIdent = TOBrace TDot TIdent = TString TComma TDot TIdent = TInt TComma TDot TIdent = TInt TComma TDot TIdent = TIdent TComma TDot TIdent = TIdent TComma TCBrace TComma TDot TIdent = & TIdent TComma TCBrace TComma TOBrace TDot TIdent = TString TComma TDot TIdent = TInt TComma TDot TIdent = TOBrace TDot TIdent = TString TComma TDot TIdent = TInt TComma TDot TIdent = TInt TComma TDot TIdent = TIdent TComma TDot TIdent = TIdent TComma TCBrace TComma TDot TIdent = TOBrace TDot TIdent = TString TComma TDot TIdent = TInt TComma TDot TIdent = TInt TComma TDot TIdent = TIdent TComma TDot TIdent = TIdent TComma TCBrace TComma TDot TIdent = & TIdent TComma TCBrace TComma TOBrace TDot TIdent = TString TComma TDot TIdent = TInt TComma TDot TIdent = TOBrace TDot TIdent = TString TComma TDot TIdent = TInt TComma TDot TIdent = TInt TComma TDot TIdent = TIdent TComma TDot TIdent = TIdent TComma TCBrace TComma TDot TIdent = TOBrace TDot TIdent = TString TComma TDot TIdent = TInt TComma TDot TIdent = TInt TComma TDot TIdent = TIdent TComma TDot TIdent = TIdent TComma TCBrace TComma TDot TIdent = & TIdent TComma TCBrace TComma TOBrace TDot TIdent = TString TComma TDot TIdent = TOBrace TDot TIdent = TString TComma TDot TIdent = TInt TComma TDot TIdent = TInt TComma TDot TIdent = TIdent TComma TDot TIdent = TIdent TComma TCBrace TComma TDot TIdent = TIdent TComma TCBrace TComma TOBrace TDot TIdent = TString TComma TDot TIdent = TOBrace TDot TIdent = TString TComma TDot TIdent = TInt TComma TDot TIdent = TInt TComma TDot TIdent = TIdent TComma TDot TIdent = TIdent TComma TCBrace TComma TCBrace TComma TCBrace TPtVirg
workqueue fix possible deadlock in idle worker rebinding currently rebind_workers and idle_worker_rebind are two-way interlocked rebind_workers waits for idle workers to finish rebinding and rebound idle workers wait for rebind_workers to finish rebinding busy workers before proceeding unfortunately this isnt enough the second wait from idle workers is implemented as follows worker_rebind rebind_workers clears worker_rebind wakes up the idle workers and then returns if cpu hotplug cycle happens again before one of the idle workers finishes the above wait_event rebind_workers will repeat the first part of the handshake set worker_rebind again and wait for the idle worker to finish rebinding and this leads to deadlock because the idle worker would be waiting for worker_rebind to clear this is fixed by adding another interlocking step at the end rebind_workers now waits for all the idle workers to finish the above worker_rebind wait before returning this ensures that all rebinding steps are complete on all idle workers before the next hotplug cycle can happen this problem was diagnosed by lai jiangshan who also posted a patch to fix the issue upon which this patch is based this is the minimal fix and further patches are scheduled for the next merge window to simplify the cpu hotplug path lkml-reference cn.fujitsu.com	kernel workqueue TIdent TOPar & TIdent TPtrOp TIdent TPtrOp TIdent TPtrOp TIdent TCPar TPtVirg Tkwd TOPar TBang -- TIdent TPtrOp TIdent TPtrOp TIdent TCPar TIdent TOPar & TIdent TPtrOp TIdent TPtrOp TIdent TCPar TPtVirg TIdent TOPar & TIdent TPtrOp TIdent TPtrOp TIdent TPtrOp TIdent TCPar TPtVirg TIdent TDot TIdent = TInt TPtVirg TIdent TOPar TIdent TDot TIdent TCPar TPtVirg TIdent TOPar TIdent TComma TIdent TCPar TIdent TOPar TIdent TComma & TIdent TPtrOp TIdent TComma TIdent TCPar TIdent TOPar TIdent TComma TIdent TCPar TIdent TOPar TIdent TComma & TIdent TPtrOp TIdent TComma TIdent TCPar TIdent TDot TIdent ++ TPtVirg Tkwd TOPar -- TIdent TDot TIdent TCPar TIdent TOPar & TIdent TPtrOp TIdent TCPar TPtVirg TIdent TOPar & TIdent TDot TIdent TCPar TPtVirg TIdent TOPar & TIdent TPtrOp TIdent TCPar TPtVirg
clk clk-gpio-gate fix active low the active low flag in the dt cell is currently ignored this occurs because of_get_named_gpio_flags does not apply the flags to the underlying struct gpio_desc so the test in clk_register_gpio_gate was bogus note that this patch changes the internal kernel api for clk_register_gpio_gate but there are currently no other users	drivers clk clk-gpio-gate Ttcons TIdent * TIdent TOPar Ttcons TIdent * TIdent TComma Tlifetime Ttype * TIdent TComma Tlifetime Ttype * TIdent TComma Tsign TIdent TComma TIdent TIdent TComma Tsign Ttype TIdent TCPar Ttcons TIdent * TIdent TOPar Ttcons TIdent * TIdent TComma Tlifetime Ttype * TIdent TComma Tlifetime Ttype * TIdent TComma Ttcons TIdent * TIdent TComma Tsign Ttype TIdent TCPar Tkwd TOPar TIdent TCPar TIdent = TIdent | TIdent TPtVirg Tkwd TOPar TIdent TOPar TIdent TCPar TCPar TIdent = TIdent TPtVirg TIdent = TIdent TOPar TIdent TComma TIdent TComma TIdent TComma TIdent TCPar TPtVirg TIdent = TIdent TOPar TIdent TComma TIdent TOPar TIdent TCPar TComma TIdent TComma TIdent TCPar TPtVirg TIdent = TIdent TOPar TIdent TComma TIdent TComma TIdent TCPar TPtVirg TIdent = TIdent TOPar TIdent TOPar TIdent TCPar TComma TIdent TComma TIdent TCPar TPtVirg TIdent TOPar TString TComma TIdent TComma TIdent TComma TIdent TCPar TPtVirg TIdent TOPar TString TComma TIdent TComma TIdent TComma TIdent TOPar TIdent TCPar TCPar TPtVirg TIdent TPtrOp TIdent = TIdent TOPar TIdent TCPar TPtVirg TIdent TPtrOp TIdent = TIdent TPtVirg Tkwd TOPar TBang TIdent TCPar TIdent TOPar TIdent TCPar TPtVirg TIdent TOPar TIdent TCPar TPtVirg Ttcons TIdent * TIdent TPtVirg Ttcons TIdent TIdent TPtVirg TIdent = TIdent TOPar TIdent TPtrOp TIdent TComma TString TComma TInt TComma & TIdent TCPar TPtVirg TIdent = TIdent TOPar TIdent TPtrOp TIdent TComma TString TComma TInt TComma TIdent TCPar TPtVirg TIdent = TIdent TOPar TIdent TCPar TPtVirg TIdent = TIdent TOPar TIdent TComma TIdent TComma TIdent TComma TIdent TComma TIdent & TIdent TComma TInt TCPar TPtVirg TIdent = TIdent TOPar TIdent TComma TIdent TComma TIdent TComma TIdent TComma TInt TCPar TPtVirg include linux clk-provider Ttcons TIdent * TIdent TOPar Ttcons TIdent * TIdent TComma Tlifetime Ttype * TIdent TComma Tlifetime Ttype * TIdent TComma Tsign TIdent TComma TIdent TIdent TComma Tsign Ttype TIdent TCPar TPtVirg Ttcons TIdent * TIdent TOPar Ttcons TIdent * TIdent TComma Tlifetime Ttype * TIdent TComma Tlifetime Ttype * TIdent TComma Ttcons TIdent * TIdent TComma Tsign Ttype TIdent TCPar TPtVirg
metag perf fix core internal perf channel mux the value written to the perf_icorex or perf_chanx register to select the performance events for the core internal and perf channel events was tmp but tmp was set to config so it would always be __number__ correct it to use config instead of tmp	arch metag kernel perf perf_event TIdent TOPar TOPar TIdent & TInt TCPar TComma TIdent TCPar TPtVirg TIdent TOPar TOPar TIdent & TInt TCPar TComma TIdent TCPar TPtVirg
iio light bh1780 assign a static name using the struct field for naming the light sensor is a bad idea when booting from the pure device tree this is null and that causes the device not to have the name property in sysfs and that in turn confuses the lsiio command to stop listing devices so instead of using the device use the hard string bh1780 which works just fine	drivers iio light bh1780 TIdent TPtrOp TIdent = TString TPtVirg TIdent TPtrOp TIdent = TIdent TPtrOp TIdent TPtVirg
spi lp-8841 return correct error code from probe the spi_lp8841_rtc_probe function misses an initialization of the return code when it fails to get its memory resource as gcc notices in function spi_lp8841_rtc_probe error ret may be used uninitialized in this function this changes the code to propagate the error from devm_ioremap_resource	drivers spi spi-lp8841-rtc TIdent TPtrOp TIdent = TIdent TOPar & TIdent TPtrOp TIdent TComma TIdent TCPar TPtVirg TIdent = TIdent TOPar TIdent TPtrOp TIdent TCPar TPtVirg Tkwd TOPar TIdent TCPar TIdent TPtrOp TIdent = TIdent TOPar & TIdent TPtrOp TIdent TComma TIdent TCPar TPtVirg Tkwd TOPar TIdent TOPar TIdent TPtrOp TIdent TCPar TCPar
bluetooth check for matching irk when looking for paired le devices if were given an rpa when checking whether were paired or not we should consult the local rpa storage whether theres a matching irk this we we ensure that hci_bdaddr_is_paired gives the right result even when trying to pair a second time with the same device with an rpa	net bluetooth hci_core Ttcons TIdent * TIdent TPtVirg TIdent = TIdent TOPar TIdent TComma TIdent TComma TIdent TCPar TPtVirg Tkwd TOPar TIdent TCPar TIdent = & TIdent TPtrOp TIdent TPtVirg TIdent = TIdent TPtrOp TIdent TPtVirg
hso fix deadlock when receiving bursts of data when the module sends bursts of data sometimes a deadlock happens in the hso driver when the tty buffer doesnt get the chance to be flushed quickly enough remove the endless while loop in function put_rxbuf_data which is called by the urb completion handler if there isnt enough room in the tty buffer discards all the data received in the urb	drivers net usb hso TIdent TIdent TPtVirg Ttype TIdent TPtVirg Ttype TIdent = TInt TPtVirg Ttype TIdent TPtVirg Tkwd TOPar TIdent && TIdent TOPar TIdent TComma & TIdent TPtrOp TIdent TCPar TCPar TIdent TOPar TIdent TCPar TPtVirg Tkwd - TInt TPtVirg TIdent = TIdent TPtrOp TIdent - TIdent TPtrOp TIdent TPtVirg TIdent = TIdent TOPar & TIdent TPtrOp TIdent TComma TIdent TPtrOp TIdent TCPar TPtVirg Tkwd TOPar TIdent >= TIdent TPtrOp TIdent TCPar TIdent TOPar & TIdent TPtrOp TIdent TComma TIdent TPtrOp TIdent TComma TIdent TPtrOp TIdent TCPar TPtVirg Tkwd TOPar TIdent TCPar Tkwd TOPar TIdent && TIdent TOPar TIdent TComma & TIdent TPtrOp TIdent TCPar TCPar TIdent TOPar TIdent TCPar TPtVirg Tkwd - TInt TPtVirg TIdent = TIdent TOPar & TIdent TPtrOp TIdent TComma TIdent TPtrOp TIdent + TIdent TPtrOp TIdent TComma TIdent TCPar TPtVirg TIdent TPtrOp TIdent += TIdent TPtVirg TIdent -= TIdent TPtVirg TIdent TOPar & TIdent TPtrOp TIdent TPtrOp TIdent TPtrOp TIdent TComma TString TComma TIdent TPtrOp TIdent TCPar TPtVirg TIdent TPtrOp TIdent TOCro TIdent TOPar TIdent TComma TIdent TCPar TCCro = TInt TPtVirg Tkwd TInt TPtVirg Tkwd TOPar TIdent == TInt TCPar TIdent TPtrOp TIdent = TInt TPtVirg TIdent TPtrOp TIdent TOCro TIdent TOPar TIdent TComma TIdent TCPar TCCro = TInt TPtVirg Tkwd TIdent TPtVirg TIdent TPtrOp TIdent = TInt TPtVirg
arm s3c64xx handle revision-specific differences in cragganmore modules allow us to supply different configurations depending on the board revision catering for changes that are visible to software	arch arm mach-s3c64xx mach-crag6410-module Tvis Tlifetime Ttcons TOBrace TIdent TIdent TPtVirg TIdent TIdent TPtVirg Tlifetime Ttype * TIdent TPtVirg Tlifetime Ttcons TIdent * TIdent TPtVirg Ttype TIdent TPtVirg Tlifetime Ttcons TIdent * TIdent TPtVirg Ttype TIdent TPtVirg TCBrace TIdent TOCro TCCro = TOBrace TOBrace TDot TIdent = TInt TComma TDot TIdent = TInt TComma TDot TIdent = TString TComma TCBrace TComma TOBrace TDot TIdent = TInt TComma TDot TIdent = TInt TComma TDot TIdent = TString TComma TCBrace TComma TOBrace TDot TIdent = TInt TComma TDot TIdent = TInt TComma TDot TIdent = TString TComma TCBrace TComma TOBrace TDot TIdent = TInt TComma TDot TIdent = TInt TComma TDot TIdent = TString TComma TCBrace TComma TOBrace TDot TIdent = TInt TComma TDot TIdent = TInt TComma TDot TIdent = TString TComma TCBrace TComma TOBrace TDot TIdent = TInt TComma TDot TIdent = TInt TComma TDot TIdent = TString TComma TCBrace TComma TOBrace TDot TIdent = TInt TComma TDot TIdent = TInt TComma TDot TIdent = TString TComma TCBrace TComma TOBrace TDot TIdent = TInt TComma TDot TIdent = TInt TComma TDot TIdent = TString TComma TCBrace TComma TOBrace TDot TIdent = TInt TComma TDot TIdent = TInt TComma TDot TIdent = TString TComma TCBrace TComma TOBrace TDot TIdent = TInt TComma TDot TIdent = TInt TComma TDot TIdent = TString TComma TCBrace TComma TOBrace TDot TIdent = TInt TComma TDot TIdent = TInt TComma TDot TIdent = TString TComma TCBrace TComma TOBrace TDot TIdent = TInt TComma TDot TIdent = TInt TComma TDot TIdent = TString TComma TDot TIdent = TIdent TComma TDot TIdent = TIdent TOPar TIdent TCPar TComma TCBrace TComma TOBrace TDot TIdent = TInt TComma TDot TIdent = TInt TComma TDot TIdent = TString TComma TCBrace TComma TOBrace TDot TIdent = TInt TComma TDot TIdent = TInt TComma TDot TIdent = TString TComma TCBrace TComma TOBrace TDot TIdent = TInt TComma TDot TIdent = TInt TComma TDot TIdent = TString TComma TDot TIdent = TIdent TComma TDot TIdent = TIdent TOPar TIdent TCPar TComma TCBrace TComma TOBrace TDot TIdent = TInt TComma TDot TIdent = TInt TComma TDot TIdent = TString TComma TCBrace TComma TOBrace TDot TIdent = TInt TComma TDot TIdent = TInt TComma TDot TIdent = TString TComma TCBrace TComma TOBrace TDot TIdent = TInt TComma TDot TIdent = TInt TComma TDot TIdent = TString TComma TDot TIdent = TIdent TComma TDot TIdent = TIdent TOPar TIdent TCPar TComma TCBrace TComma TOBrace TDot TIdent = TInt TComma TDot TIdent = TInt TComma TDot TIdent = TString TComma TDot TIdent = TIdent TComma TDot TIdent = TIdent TOPar TIdent TCPar TComma TCBrace TComma TOBrace TDot TIdent = TInt TComma TDot TIdent = TInt TComma TDot TIdent = TString TComma TDot TIdent = TIdent TComma TDot TIdent = TIdent TOPar TIdent TCPar TComma TCBrace TComma TOBrace TDot TIdent = TInt TComma TDot TIdent = TInt TComma TDot TIdent = TString TComma TDot TIdent = TIdent TComma TDot TIdent = TIdent TOPar TIdent TCPar TComma TCBrace TComma TOBrace TDot TIdent = TInt TComma TDot TIdent = TInt TComma TDot TIdent = TString TComma TCBrace TComma TOBrace TDot TIdent = TInt TComma TDot TIdent = TInt TComma TDot TIdent = TString TComma TDot TIdent = TIdent TComma TDot TIdent = TIdent TOPar TIdent TCPar TComma TCBrace TComma TOBrace TDot TIdent = TInt TComma TDot TIdent = - TInt TComma TDot TIdent = TString TComma TDot TIdent = TIdent TComma TDot TIdent = TIdent TOPar TIdent TCPar TComma TCBrace TComma TCBrace TPtVirg Tvis Tlifetime Ttcons TOBrace TIdent TIdent TPtVirg Tlifetime Ttype * TIdent TPtVirg Tlifetime Ttcons TIdent * TIdent TPtVirg Ttype TIdent TPtVirg Tlifetime Ttcons TIdent * TIdent TPtVirg Ttype TIdent TPtVirg TCBrace TIdent TOCro TCCro = TOBrace TOBrace TDot TIdent = TInt TComma TDot TIdent = TString TComma TCBrace TComma TOBrace TDot TIdent = TInt TComma TDot TIdent = TString TComma TCBrace TComma TOBrace TDot TIdent = TInt TComma TDot TIdent = TString TComma TCBrace TComma TOBrace TDot TIdent = TInt TComma TDot TIdent = TString TComma TCBrace TComma TOBrace TDot TIdent = TInt TComma TDot TIdent = TString TComma TCBrace TComma TOBrace TDot TIdent = TInt TComma TDot TIdent = TString TComma TCBrace TComma TOBrace TDot TIdent = TInt TComma TDot TIdent = TString TComma TCBrace TComma TOBrace TDot TIdent = TInt TComma TDot TIdent = TString TComma TCBrace TComma TOBrace TDot TIdent = TInt TComma TDot TIdent = TString TComma TCBrace TComma TOBrace TDot TIdent = TInt TComma TDot TIdent = TString TComma TCBrace TComma TOBrace TDot TIdent = TInt TComma TDot TIdent = TString TComma TCBrace TComma TOBrace TDot TIdent = TInt TComma TDot TIdent = TString TComma TDot TIdent = TIdent TComma TDot TIdent = TIdent TOPar TIdent TCPar TComma TCBrace TComma TOBrace TDot TIdent = TInt TComma TDot TIdent = TString TComma TCBrace TComma TOBrace TDot TIdent = TInt TComma TDot TIdent = TString TComma TCBrace TComma TOBrace TDot TIdent = TInt TComma TDot TIdent = TString TComma TDot TIdent = TIdent TComma TDot TIdent = TIdent TOPar TIdent TCPar TComma TCBrace TComma TOBrace TDot TIdent = TInt TComma TDot TIdent = TString TComma TCBrace TComma TOBrace TDot TIdent = TInt TComma TDot TIdent = TString TComma TCBrace TComma TOBrace TDot TIdent = TInt TComma TDot TIdent = TString TComma TDot TIdent = TIdent TComma TDot TIdent = TIdent TOPar TIdent TCPar TComma TCBrace TComma TOBrace TDot TIdent = TInt TComma TDot TIdent = TString TComma TDot TIdent = TIdent TComma TDot TIdent = TIdent TOPar TIdent TCPar TComma TCBrace TComma TOBrace TDot TIdent = TInt TComma TDot TIdent = TString TComma TDot TIdent = TIdent TComma TDot TIdent = TIdent TOPar TIdent TCPar TComma TCBrace TComma TOBrace TDot TIdent = TInt TComma TDot TIdent = TString TComma TDot TIdent = TIdent TComma TDot TIdent = TIdent TOPar TIdent TCPar TComma TCBrace TComma TOBrace TDot TIdent = TInt TComma TDot TIdent = TString TComma TCBrace TComma TOBrace TDot TIdent = TInt TComma TDot TIdent = TString TComma TDot TIdent = TIdent TComma TDot TIdent = TIdent TOPar TIdent TCPar TComma TCBrace TComma TOBrace TDot TIdent = TInt TComma TDot TIdent = TString TComma TDot TIdent = TIdent TComma TDot TIdent = TIdent TOPar TIdent TCPar TComma TCBrace TComma TCBrace TPtVirg Tkwd TOPar TIdent == TIdent TOCro TIdent TCCro TDot TIdent && TOPar TIdent TOCro TIdent TCCro TDot TIdent == TInt || TIdent == TIdent TOCro TIdent TCCro TDot TIdent TCPar TCPar Tkwd TOPar TIdent == TIdent TOCro TIdent TCCro TDot TIdent TCPar
cifs override unmappable incoming uids and gids the cifs protocol has a space for uids and gids while linux only supports a space today instead of silently truncating cifs ids replace cifs ids that do not fit in the linux id space with the default uid and gids for the cifs mount	fs cifs inode TIdent TPtrOp TIdent = TIdent TPtrOp TIdent TPtVirg Tkwd TOPar TBang TOPar TIdent TPtrOp TIdent & TIdent TCPar TCPar TIdent TIdent = TIdent TOPar TIdent TPtrOp TIdent TCPar TPtVirg Tkwd TOPar TIdent < TOPar TOPar TIdent TCPar - TInt TCPar TCPar TIdent TPtrOp TIdent = TIdent TPtVirg TIdent TPtrOp TIdent = TIdent TPtrOp TIdent TPtVirg Tkwd TOPar TBang TOPar TIdent TPtrOp TIdent & TIdent TCPar TCPar TIdent TIdent = TIdent TOPar TIdent TPtrOp TIdent TCPar TPtVirg Tkwd TOPar TIdent < TOPar TOPar TIdent TCPar - TInt TCPar TCPar TIdent TPtrOp TIdent = TIdent TPtVirg Tkwd TOPar TIdent TPtrOp TIdent & TIdent TCPar TIdent TPtrOp TIdent = TIdent TPtrOp TIdent TPtVirg TIdent TPtrOp TIdent = TIdent TOPar TIdent TPtrOp TIdent TCPar TPtVirg Tkwd TOPar TIdent TPtrOp TIdent & TIdent TCPar TIdent TPtrOp TIdent = TIdent TPtrOp TIdent TPtVirg TIdent TPtrOp TIdent = TIdent TOPar TIdent TPtrOp TIdent TCPar TPtVirg
net allow dcbnl to use other namespaces besides init_net allow dcb and net namespace to work together this is useful if you have containers that are bound to phys interfaces that want to also manage their dcb attributes the net namespace is taken from of the netlink skb	net dcb dcbnl Tkwd TOPar TBang TIdent TOPar TIdent TComma & TIdent TCPar TCPar Tkwd - TIdent TPtVirg TIdent = TIdent TOPar TIdent TComma TIdent TOPar TIdent TOCro TIdent TCCro TCPar TCPar TPtVirg TIdent = TIdent TOPar & TIdent TComma TIdent TOPar TIdent TOCro TIdent TCCro TCPar TCPar TPtVirg TIdent = TIdent TOPar TIdent TComma TIdent TComma TIdent TCPar TPtVirg TIdent = TIdent TOPar TIdent TComma & TIdent TComma TIdent TCPar TPtVirg
bgmac register napi before the device napi should get registered before the netdev and not after	drivers net ethernet broadcom bgmac TIdent TOPar TIdent TComma & TIdent TPtrOp TIdent TComma TIdent TComma TIdent TCPar TPtVirg TIdent TOPar TIdent TComma & TIdent TPtrOp TIdent TComma TIdent TComma TIdent TCPar TPtVirg TIdent TOPar & TIdent TPtrOp TIdent TCPar TPtVirg TIdent TOPar & TIdent TPtrOp TIdent TCPar TPtVirg
fix the pause_time test pause_time is unsigned so it cant be less than zero the bug means that we allow invalid pause-times	drivers net ethernet freescale fman fman_dtsec Tkwd TOPar TIdent <= TInt TCPar Tkwd TOPar TIdent < TInt && TIdent <= TInt TCPar
power twl4030_madc_battery add missing module_alias without module_alias twl4030_madc_battery wont get loaded automatically	drivers power twl4030_madc_battery TIdent TOPar TString TCPar TPtVirg
btrfs fix full backref problem when inserting shared block reference if we create several snapshots at the same time the following bug_on will be triggered kernel bug at steps to reproduce mount cd for do touch done for do mkdir for do btrfs sub snap done done the reason is before transaction commit some operations changed the fs tree and new tree blocks were allocated because of cow we used the implicit non-shared back reference for those newly allocated tree blocks because they were not shared by two or more trees and then we created the first snapshot for the fs tree according to the back reference rules we also used implicit back refs for the child tree blocks of the root node of the fs tree now those child were shared by two trees then we didnt deal with the delayed references and continued to change the fs treecreated the second snapshot and inserted the dir item of the new snapshot into the fs tree according to the rules of the back reference we added full back refs for those tree blocks whose parents have be shared by two trees now some newly allocated tree blocks had two types of the references as we know the delayed reference system handles these delayed references from back to front and the full delayed reference is inserted after the implicit ones so when we dealt with the back references of those newly allocated tree blocks the full references was dealt with at first and if the first reference is a shared back reference and the tree block that the reference points to is newly allocated it would be considered as a tree block which is shared by two or more trees when it is allocated and should be a full back reference not a implicit one the flag of its reference also should be set to full_backref but in fact it was a non-shared tree block with a implicit reference at beginning so it was not compulsory to set the flags to full_backref so bug_on was triggered we have several methods to fix this bug __number__ deal with delayed references after the snapshot is created and before we change the source tree of the snapshot this is the easiest and safest way __number__ modify the sort method of the delayed reference tree make the full delayed references be inserted before the implicit ones it is also very easy but i dont know if it will introduce some problems or not __number__ modify select_delayed_ref and make it select the implicit delayed reference at first this way is not so good because it may wastes cpu time if we have lots of delayed references __number__ set the flags to full_backref this method is a little complex comparing with the way i chose the way to fix it	fs btrfs transaction TIdent = TIdent TOPar TIdent TComma TIdent TComma TOPar Tsign Ttype TCPar - TInt TCPar TPtVirg Tkwd TOPar TIdent TCPar Tkwd TIdent TPtVirg
clk atlas7 fix pll missed divide nr in fraction mode pll vco frequency is given by fvco fref __number__ nf nr in integer-n mode or by fvco fref ssn nr in spread spectrum fractional-n mode thus fix the missing part of nr	drivers clk sirf clk-atlas7 TIdent TOPar TIdent TComma TIdent TCPar TPtVirg
nfsd41 error out when client sets maxreq_sz or maxresp_sz too small according to rfc5661 if the client selects a value for ca_maxresponsesize such that a replier on a channel could never send a server should return nfs4err_toosmall in the create_session reply so error out when the client sets a maxreq_sz less than the minimum possible sequence request size or sets a maxresp_sz less than the minimum possible sequence reply size	fs nfsd nfs4state TDefine TIdent TOPar TOPar TInt * TInt + TInt + TInt + TIdent TOPar TIdent TCPar + TInt TCPar * Tkwd TOPar TIdent TCPar TCPar TDefine TIdent TOPar TOPar TInt + TInt + TInt + TInt + TIdent TOPar TIdent TCPar + TInt TCPar * Tkwd TOPar TIdent TCPar TCPar Tvis TIdent TIdent TOPar Ttcons TIdent TIdent TCPar Tkwd TIdent TDot TIdent < TIdent || TIdent TDot TIdent < TIdent TPtVirg TIdent = TIdent TPtVirg Tkwd TOPar TIdent TOPar TIdent TPtrOp TIdent TCPar TCPar Tkwd TIdent TPtVirg
asoc ad193x-spi fixup ad193x_spi_id table ad1939 is missed from the table so add it ad1936 and ad1937 are controlled by i2c interface so remove them	sound soc codecs ad193x-spi Tvis Tlifetime Ttcons TIdent TIdent TOCro TCCro = TOBrace TOBrace TString TComma TIdent TComma TCBrace TComma TOBrace TString TComma TIdent TComma TCBrace TComma TOBrace TString TComma TIdent TComma TCBrace TComma TOBrace TString TComma TIdent TComma TCBrace TComma TOBrace TString TComma TIdent TComma TCBrace TComma TOBrace TString TComma TIdent TComma TCBrace TComma TOBrace TCBrace TComma TCBrace TPtVirg
fix rtnl notifications on iface deletion the function geneve_dev_create_fb only used by ovs never calls rtnl_configure_link the consequence is that is never set to rtnl_link_initialized during the deletion phase the function rollback_registered_many sends a rtm_dellink only if is set to rtnl_link_initialized	drivers net geneve TIdent = TIdent TOPar TIdent TComma TIdent TCPar TPtVirg Tkwd TOPar TIdent < TInt TCPar Tkwd TIdent TPtVirg
isdn icn buffer overflow in icn_command this buffer over was detected using static analysis icn_command error format string overflow buf_size __number__ length __number__ the calculation for the length of the string is off because it assumes that the dial buffer holds a __number__ character string but actually it is at most __number__ characters and nul i have removed the dial buffer because it isnt needed the maximum length of the string is actually __number__ characters and a nul i have made the cbuf array large enough to hold it and changed the sprintf to an snprintf as a further safety enhancement	drivers isdn icn icn Ttype TIdent TOCro TInt TCCro TPtVirg Ttype TIdent TOCro TInt TCCro TPtVirg Ttype TIdent TOCro TInt TCCro TPtVirg TIdent TOPar TIdent TComma Tkwd TOPar TIdent TCPar TComma TString TComma TOPar Ttype TCPar TOPar TIdent + TInt TCPar TComma TIdent TComma TIdent TComma TIdent TPtrOp TIdent TDot TIdent TDot TIdent TComma TIdent TPtrOp TIdent TDot TIdent TDot TIdent TComma TIdent TPtrOp TIdent TDot TIdent TDot TIdent TCPar TPtVirg TIdent TOPar TIdent TComma TIdent TCPar TPtVirg TIdent TOPar TIdent TComma TString TComma TOPar Ttype TCPar TOPar TIdent + TInt TCPar TComma TIdent TComma TIdent TComma TIdent TPtrOp TIdent TDot TIdent TDot TIdent TComma TIdent TPtrOp TIdent TDot TIdent TDot TIdent TComma TIdent TPtrOp TIdent TDot TIdent TDot TIdent TCPar TPtVirg
gma500 fix leak of uncached page this was reported a long time ago and i apologize to whoever it was that reported it as ive lost the original report	drivers gpu drm gma500 psb_drv TIdent TOPar TIdent TPtrOp TIdent TComma TInt TCPar TPtVirg
xfs xfs_filemap_pmd_fault treats read faults as write faults the code initially committed didnt have the same checks for write faults as the dax_pmd_fault code and hence treats all faults as write faults we can get read faults through this path because they is no pmd_mkwrite path for write faults similar to the normal page fault path hence we need to ensure that we only do updates on write faults and freeze protection is unnecessary for read faults	fs xfs xfs_file Tkwd TOPar TIdent & TIdent TCPar TIdent TOPar TIdent TPtrOp TIdent TCPar TPtVirg TIdent TOPar TIdent TPtrOp TIdent TCPar TPtVirg TIdent TOPar TIdent TPtrOp TIdent TCPar TPtVirg TIdent TOPar TIdent TPtrOp TIdent TCPar TPtVirg Tkwd TOPar TIdent & TIdent TCPar TIdent TOPar TIdent TPtrOp TIdent TCPar TPtVirg TIdent TOPar TIdent TPtrOp TIdent TCPar TPtVirg
ath10k apply chainmask settings to vdev on creation it appears it takes more than just setting the hardwares chainmask to make things work well without this patch a vdev would only use rates when chainmask was set to setting the nss number of spatial streams on the vdev helps the firmwares rate-control algorithm work properly	drivers net wireless ath ath10k mac Tvis Ttype TIdent TOPar Ttcons TIdent * TIdent TComma TIdent TIdent TComma Tlifetime Ttype * TIdent TCPar Tkwd TOPar TIdent == TInt || TIdent == TInt || TIdent == TInt || TIdent == TInt || TIdent == TInt TCPar Tkwd TPtVirg TIdent TOPar TIdent TComma TString TComma TIdent TComma TIdent TCPar TPtVirg TIdent TOPar TIdent TComma TIdent TComma TString TCPar TPtVirg TIdent TOPar TIdent TComma TIdent TComma TString TCPar TPtVirg Tvis TIdent TIdent TOPar TIdent TIdent TCPar Tkwd TOPar TOPar TIdent & TInt TCPar == TInt TCPar Tkwd TInt TPtVirg Tkwd TOPar TOPar TIdent & TInt TCPar == TInt TCPar Tkwd TInt TPtVirg Tkwd TOPar TOPar TIdent & TInt TCPar == TInt TCPar Tkwd TInt TPtVirg Tkwd TInt TPtVirg Tkwd TOPar TIdent TPtrOp TIdent TCPar TIdent TIdent = TIdent TOPar TIdent TPtrOp TIdent TCPar TPtVirg TIdent = TIdent TPtrOp TIdent TDot TIdent TPtrOp TIdent TPtVirg TIdent = TIdent TOPar TIdent TComma TIdent TPtrOp TIdent TComma TIdent TComma TIdent TCPar TPtVirg Tkwd TOPar TIdent TCPar TIdent TOPar TIdent TComma TString TComma TIdent TPtrOp TIdent TComma TIdent TPtrOp TIdent TComma TIdent TComma TIdent TCPar TPtVirg Tkwd TIdent TPtVirg
staging unisys visorhid correctly map keys with extended scancodes the most-noticed key that wasnt being mapped correctly was right-alt which is the altgr key on many non-us keyboards used to select many extended characters	drivers staging unisys visorhid visorhid Tvis Tsign Ttype TIdent TOCro TInt TCCro = TOBrace TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TIdent TComma TIdent TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TIdent TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TIdent TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TIdent TComma TIdent TComma TIdent TComma TInt TComma TIdent TComma TInt TComma TIdent TComma TInt TComma TIdent TComma TIdent TComma TIdent TComma TIdent TComma TIdent TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TCBrace TPtVirg Tvis Tsign Ttype TIdent TOCro TInt TCCro = TOBrace TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TIdent TComma TIdent TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TIdent TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TIdent TComma TIdent TComma TIdent TComma TInt TComma TIdent TComma TInt TComma TIdent TComma TInt TComma TIdent TComma TIdent TComma TIdent TComma TIdent TComma TIdent TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TCBrace TPtVirg Tkwd TOPar TIdent = TInt TPtVirg TIdent < TIdent TOPar TIdent TCPar TPtVirg TIdent ++ TCPar TIdent TOPar TIdent TOCro TIdent TCCro TComma TIdent TPtrOp TIdent TCPar TPtVirg TIdent = TIdent TOCro TOPar TIdent >> TInt TCPar & TInt TCCro TPtVirg TIdent = TIdent TOCro TOPar TIdent >> TInt TCPar & TInt TCCro TPtVirg
defer assignment of until after all possible mallocs as we may invoke the shrinker whilst trying to allocate memory to hold the gtt_space for this object we need to be careful not to mark the drm_mm_node as activated by assigning it to this object before we have finished our sequence of allocations note we also need to move the binding of the object into the actual pagetables down a bit the best way seems to be to move it out into the callsites danvet added small note to commit message to summarize review discussion	drivers gpu drm i915 i915_gem TIdent = TIdent TOPar & TIdent TPtrOp TIdent TDot TIdent TComma TIdent TComma TIdent TComma TIdent TPtrOp TIdent TComma TInt TComma TIdent TPtrOp TIdent TDot TIdent TComma TIdent TCPar TPtVirg TIdent = TIdent TOPar & TIdent TPtrOp TIdent TDot TIdent TComma TIdent TComma TIdent TComma TIdent TPtrOp TIdent TComma TInt TComma TIdent TPtrOp TIdent TDot TIdent TComma TIdent TCPar TPtVirg TIdent = TIdent TOPar TIdent TComma TIdent TComma TIdent TComma TIdent TPtrOp TIdent TComma TInt TComma TIdent TPtrOp TIdent TDot TIdent TComma TIdent TCPar TPtVirg TIdent TPtrOp TIdent = TIdent TOPar TIdent TComma TIdent TComma TIdent TComma TIdent TPtrOp TIdent TComma TInt TComma TIdent TPtrOp TIdent TDot TIdent TComma TIdent TCPar TPtVirg TIdent = TIdent TOPar TIdent TComma TIdent TComma TIdent TComma TIdent TPtrOp TIdent TComma TIdent TCPar TPtVirg TIdent TPtrOp TIdent = TIdent TOPar TIdent TComma TIdent TComma TIdent TComma TIdent TPtrOp TIdent TComma TIdent TCPar TPtVirg Tkwd TOPar TIdent == TIdent TCPar Tkwd TOPar TIdent TPtrOp TIdent == TIdent TCPar Tkwd TOPar TIdent TOPar TBang TIdent TOPar TIdent TComma TIdent TComma TIdent TPtrOp TIdent TCPar TCPar TCPar Tkwd TOPar TIdent TOPar TBang TIdent TOPar TIdent TComma TIdent TPtrOp TIdent TComma TIdent TPtrOp TIdent TCPar TCPar TCPar TIdent TOPar TIdent TCPar TPtVirg TIdent TOPar TIdent TPtrOp TIdent TCPar TPtVirg TIdent TPtrOp TIdent = TIdent TPtVirg TIdent TOPar TIdent TCPar TPtVirg TIdent TOPar TIdent TPtrOp TIdent TCPar TPtVirg TIdent TPtrOp TIdent = TIdent TPtVirg Tkwd TOPar TBang TIdent TPtrOp TIdent TDot TIdent TCPar TIdent TOPar TIdent TComma TIdent TPtrOp TIdent TCPar TPtVirg TIdent TPtrOp TIdent = TIdent TPtVirg TIdent TPtrOp TIdent = TIdent TPtrOp TIdent TPtVirg TIdent TPtrOp TIdent = TIdent TPtrOp TIdent TPtrOp TIdent TPtVirg TIdent = TIdent TPtrOp TIdent == TIdent && TOPar TIdent TPtrOp TIdent & TOPar TIdent - TInt TCPar TCPar == TInt TPtVirg TIdent = TIdent TPtrOp TIdent TPtrOp TIdent == TIdent && TOPar TIdent TPtrOp TIdent TPtrOp TIdent & TOPar TIdent - TInt TCPar TCPar == TInt TPtVirg Ttcons TIdent * TIdent = TIdent TPtrOp TIdent TDot TIdent TPtrOp TIdent TPtVirg Tkwd TOPar TBang TIdent TPtrOp TIdent TDot TIdent TCPar TIdent TOPar TIdent TComma TIdent TPtrOp TIdent TCPar TPtVirg
ext4 fix ext4_evict_inode racing against workqueue processing code commit ext4 move work from io_end to inode triggered a regression when running xfstest when the file system is mounted with dioread_nolock the problem is that after ext4_evict_inode calls ext4_ioend_wait this guarantees that last io_end structure has been freed but it does not guarantee that the workqueue structure which was moved into the inode by commit is actually finished once ext4_flush_completed_io calls ext4_free_io_end on cpu this will allow ext4_ioend_wait to return on cpu at which point the evict_inode codepath can race against the workqueue code on cpu accessing to find the next item of work to do fix this by calling cancel_work_sync in ext4_ioend_wait which will be renamed ext4_ioend_shutdown since it is only used by ext4_evict_inode also move the call to ext4_ioend_shutdown until after truncate_inode_pages and filemap_write_and_wait are called to make sure all dirty pages have been written back and flushed from the page cache first bug unable to handle kernel null pointer dereference at null ip __number__ __number__ oops __number__ smp debug_pagealloc modules linked in pid __number__ comm not tainted bochs bochs eip eflags __number__ cpu __number__ eip is at eax __number__ ebx __number__ ecx edx __number__ esi edi __number__ ebp esp ds es fs gs __number__ ss __number__ cr0 cr2 __number__ cr3 cr4 __number__ dr0 __number__ dr1 __number__ dr2 __number__ dr3 __number__ dr6 __address__ dr7 __number__ process pid __number__ stack __number__ __number__ __number__ __number__ __number__ __number__ __number__ __number__ call trace code __number__ __number__ __number__ ac ff c1 __number__ __number__ db __number__ c6 __number__ a8 __number__ __number__ __number__ __number__ c3 __number__ db __number__ __number__ b0 ff c1 __number__ __number__ __number__ b4 ff c1 __number__ __number__ f0 e8 __number__ ff ff ff __number__ __number__ f0 __number__ __number__ b8 ff c1 c1 __number__ __number__ c9 __number__ eip cr2 __number__ end trace	fs ext4 ext4 Tvis Ttype TIdent TOPar Ttcons TIdent * TCPar TPtVirg Tvis Ttype TIdent TOPar Ttcons TIdent * TCPar TPtVirg fs ext4 inode TIdent TOPar TIdent TCPar TPtVirg TIdent TOPar TIdent TCPar TPtVirg TIdent TOPar TIdent TCPar TPtVirg fs ext4 page-io Ttype TIdent TOPar Ttcons TIdent * TIdent TCPar Ttype TIdent TOPar Ttcons TIdent * TIdent TCPar Tkwd TOPar TIdent TOPar & TIdent TOPar TIdent TCPar TPtrOp TIdent TCPar TCPar TIdent TOPar & TIdent TOPar TIdent TCPar TPtrOp TIdent TCPar TPtVirg
acpi hotplug pci avoid parent bus rescans on spurious device checks in the current acpiphp notify handler we always go directly for a rescan of the parent bus if we get a device check notification for a device that is not a bridge however this obviously is overzealous if nothing really changes because this way we may rescan the whole pci hierarchy pretty much in vain that happens on alex williamsons machine whose acpi tables contain device objects that are supposed to coresspond to pcie root ports but those ports arent physically present or at least they arent visible in the pci config space to us the bios generates multiple device check notifies for those objects during boot and for each of them we go straight for the parent bus rescan but the parent bus is the root bus in this particular case in consequence we rescan the whole pci bus from the top several times in a row which is completely unnecessary increases boot time by after previous fixes and generates excess dmesg output from the pci subsystem fix the problem by checking if we can find anything new in the slot corresponding to the device weve got a device check notify for and doing nothig if thats not the case the spec acpi __float__ section appears to mandate this behavior as it says device check used to notify ospm that the device either appeared or disappeared if the device has appeared ospm will re-enumerate from the parent if the device has disappeared ospm will invalidate the state of the device ospm may optimize out re-enumeration therefore according to the spec we are free to do nothing if nothing changes references	drivers pci hotplug acpiphp_glue Tvis Ttype TIdent TOPar Ttcons TIdent * TIdent TCPar Ttcons TIdent * TIdent TPtVirg TIdent TOPar TIdent TComma & TIdent TPtrOp TIdent TComma TIdent TCPar TIdent TOPar TIdent TOPar TIdent TCPar TCPar TPtVirg Tkwd TIdent TOPar TIdent TPtrOp TIdent TComma TIdent TOPar TIdent TPtrOp TIdent TComma TInt TCPar TCPar TPtVirg TIdent = TIdent TOPar TIdent TCPar TPtVirg TIdent TOPar TIdent TComma & TIdent TPtrOp TIdent TComma TIdent TCPar TIdent TOPar TIdent TOPar TIdent TCPar TCPar TPtVirg TIdent = TIdent TOPar TIdent TComma TIdent TOPar TIdent TPtrOp TIdent TComma TInt TCPar TCPar TPtVirg Tkwd TOPar TIdent TCPar Tkwd TOPar TIdent TCPar Ttcons TIdent * TIdent = TIdent TPtrOp TIdent TPtVirg Ttype TIdent TPtVirg TIdent TOPar TIdent TPtrOp TIdent TCPar TPtVirg TIdent TOPar & TIdent TPtrOp TIdent TCPar TPtVirg TIdent = TIdent TOPar TIdent TCPar TPtVirg TIdent TOPar & TIdent TPtrOp TIdent TCPar TPtVirg Tkwd TOPar TIdent TCPar TIdent TOPar TIdent TPtrOp TIdent TCPar TPtVirg
revert fsnotify fix oops in fsnotify_clear_marks_by_group_flags this reverts commit a2673b6e040663bf16a552f8619e6bde9f4b9acf kinglong mee reports a memory leak with that patch and jan kara confirms thanks for report you are right that my patch introduces a race between fsnotify kthread and fsnotify_destroy_group which can result in leaking inotify event on group destruction i havent yet decided whether the right fix is not to queue events for dying notification group as that is pointless anyway or whether we should just fix the original problem whenever i look at fsnotify code mark handling i get lost in the maze of locks lists and subtle differences between how different notification systems handle notification marks ill think about it over night and after thinking about it jan says ok i have looked into the code some more and i found another relatively simple way of fixing the original oops it will be imho better than trying to fixup this issue which has more potential for breakage ill ask linus to revert the fsnotify fix he already merged and send a new fix	fs notify mark TIdent TOPar & TIdent TPtrOp TIdent TCPar TPtVirg Tkwd TOPar TIdent TPtrOp TIdent TPtrOp TIdent TCPar TIdent TPtrOp TIdent TPtrOp TIdent TOPar TIdent TComma TIdent TCPar TPtVirg TIdent TOPar & TIdent TPtrOp TIdent TComma TIdent TCPar TPtVirg Ttcons TIdent * TIdent TPtVirg TIdent = TIdent TPtrOp TIdent TPtVirg Tkwd TOPar TIdent && TIdent TPtrOp TIdent TPtrOp TIdent TCPar TIdent TPtrOp TIdent TPtrOp TIdent TOPar TIdent TComma TIdent TCPar TPtVirg
tty fix data race on race on buffer data happens when newly committed data is picked up by an old flush work in the following scenario __tty_buffer_request_room does a plain write of no barriers were executed before that at this point flush_to_ldisc reads this new value of commit and reads buffer data no barriers in between the committed buffer data is not necessary visible to flush_to_ldisc similar bug happens when tty_schedule_flip commits data update commit with smp_store_release and read commit with smp_load_acquire as it is commit that signals data readiness this is orthogonal to the existing synchronization on which is required to not dismiss a buffer with unconsumed data the data race was found with kernelthreadsanitizer ktsan	drivers tty tty_buffer TIdent TOPar & TIdent TPtrOp TIdent TComma TIdent TPtrOp TIdent TCPar TPtVirg TIdent TPtrOp TIdent = TIdent TPtrOp TIdent TPtVirg TIdent TOPar & TIdent TPtrOp TIdent TPtrOp TIdent TComma TIdent TPtrOp TIdent TPtrOp TIdent TCPar TPtVirg TIdent TPtrOp TIdent TPtrOp TIdent = TIdent TPtrOp TIdent TPtrOp TIdent TPtVirg TIdent = TIdent TOPar & TIdent TPtrOp TIdent TCPar - TIdent TPtrOp TIdent TPtVirg TIdent = TIdent TPtrOp TIdent - TIdent TPtrOp TIdent TPtVirg
powerpc fix size of st_nlink on commit e57f93cc53b7 powerpc get rid of nlink_t uses switch to explicitly-sized type changed the size of st_nlink on ppc64 from a long to a short resulting in boot failures	arch powerpc include asm stat Tsign Ttype TIdent TPtVirg Tsign Ttype TIdent TPtVirg
rbd dont drop the rbd_id too early currently an rbd devices id is released when it is removed but it is done before the code is run to clean up sysfs-related files such as its possible that an rbd is still in use after the rbd_remove call has been made its essentially the same as an active inode that stays around after it has been removed--until its final close operation this means that the id shows up as free for reuse at a time it should not be the effect of this was seen by jens rehpoehler who had a filesystem mounted on an rbd device unmapped that filesystem without unmounting found that the mount still worked properly but hit a panic when he attempted to re-map a new rbd device this re-map attempt found the previously-unmapped id available the subsequent attempt to reuse it was met with a panic while attempting to re-install the sysfs entry for the new mapped device fix this by holding off putting the rbd id until the rbd_device release function is called--when the last reference is finally dropped note this fixes	drivers block rbd TIdent TOPar TIdent TCPar TPtVirg TIdent TOPar TIdent TCPar TPtVirg TIdent TOPar TIdent TCPar TPtVirg
pci add dell studio __number__ to blacklist the dell studio __number__ also doesnt suspend correctly when crs is enabled details at	arch x86 pci acpi Tvis Tlifetime Ttcons TIdent TIdent TOCro TCCro = TOBrace TOBrace TDot TIdent = TIdent TComma TDot TIdent = TString TComma TDot TIdent = TOBrace TIdent TOPar TIdent TComma TString TCPar TComma TIdent TOPar TIdent TComma TString TCPar TComma TCBrace TComma TCBrace TComma TOBrace TDot TIdent = TIdent TComma TDot TIdent = TString TComma TDot TIdent = TOBrace TIdent TOPar TIdent TComma TString TCPar TComma TCBrace TComma TCBrace TComma TOBrace TDot TIdent = TIdent TComma TDot TIdent = TString TComma TDot TIdent = TOBrace TIdent TOPar TIdent TComma TString TCPar TComma TIdent TOPar TIdent TComma TString TCPar TComma TIdent TOPar TIdent TComma TString TCPar TComma TCBrace TComma TCBrace TComma TOBrace TDot TIdent = TIdent TComma TDot TIdent = TString TComma TDot TIdent = TOBrace TIdent TOPar TIdent TComma TString TCPar TComma TIdent TOPar TIdent TComma TString TCPar TComma TIdent TOPar TIdent TComma TString TCPar TComma TCBrace TComma TCBrace TComma TOBrace TCBrace TComma TCBrace TPtVirg
powerpc never handle vsx alignment exceptions from kernel the vsx alignment handler needs to write out the existing vsx state to memory before operating on it flush_vsx_to_thread if we take a vsx alignment exception in the kernel bad things will happen it looks like we could write the kernel state out to the user process or we could handle the kernel exception using data from the user process depending if msr_vsx is set or not worse still if the code to read or write the vsx state causes an alignment exception we will recurse forever i ended up with hundreds of megabytes of kernel stack to look through as a result floating point and spe code have similar issues but already include a user check add the same check to emulate_vsx with this patch any unaligned vsx loads and stores in the kernel will show up as a clear oops rather than silent corruption of kernel or userspace vsx state or worse corruption of a potentially unlimited amount of kernel memory	arch powerpc kernel align Tkwd TOPar TIdent TOPar TBang TIdent TOPar TIdent TCPar TCPar TCPar Tkwd TInt TPtVirg
fix address range for asynchronous stack git commit dc7ee00d4771 s390 lowcore stack pointer offsets introduced a regression in regard to s390_backtrace the stack pointer for the asynchronous stack in the lowcore now has an additional offset applied this offset needs to be taken into account in the calculation for the low and high address for the stack this bug was already partially fixed with commit fix address ranges for asynchronous and panic stack this patch fixes it also for the oprofile code	arch s390 oprofile backtrace Tsign Ttype TIdent TComma TIdent TPtVirg Tsign Ttype TIdent TPtVirg TIdent = TIdent + Tkwd TOPar Ttcons TIdent TCPar TPtVirg TIdent = TIdent TOPar & TIdent TComma TIdent TComma TIdent TDot TIdent + TIdent - TIdent TComma TIdent TDot TIdent + TIdent TCPar TPtVirg TIdent = TIdent TOPar & TIdent TComma TIdent TComma TIdent TDot TIdent - TIdent TComma TIdent TDot TIdent TCPar TPtVirg
use the correct destructor for freeing requests on error after allocating from the slab cache we then need to free the request back into the slab cache upon error and not call kfree as that leads to eventual memory corruption fixes regression from commit efab6d8dd158fdccbe6a030f89fbf9ca0a9564e4 author chris wilson chris-wilson.co.uk date tue apr __number__ __number__ use a separate slab for requests	drivers gpu drm i915 i915_gem Tkwd TOPar TIdent TCPar Tkwd TIdent TPtVirg Tkwd TOPar TIdent TCPar TIdent TOPar TIdent TCPar TPtVirg Tkwd TIdent TPtVirg Tkwd TOPar TIdent TCPar Tkwd TIdent TPtVirg Tkwd TOPar TIdent TCPar TIdent TOPar TIdent TCPar TPtVirg Tkwd TIdent TPtVirg TIdent TDotDot TIdent TOPar TIdent TPtrOp TIdent TComma TIdent TCPar TPtVirg TIdent TOPar TIdent TPtrOp TIdent TComma TIdent TCPar TPtVirg Tkwd TIdent TPtVirg
btrfs device_replace fix deadlock for nocow case commit cb7ab02156e4 cause a following deadlock found by thread1 is commiting transaction which is blocked at btrfs_scrub_pause thread2 is calling btrfs_file_aio_write which has held inodes and commit transactionblocked because thread1 is committing transaction thread3 is copy_nocow_page worker which will also try to hold inode so thread3 will wait thread1 finished thread4 is waiting pending workers finished which will wait thread3 finished so the problem is like this deadlock happens we fix it by letting thread1 go firstly which means we wont block transaction commit while we are waiting pending workers finished	fs btrfs scrub TIdent TOPar & TIdent TPtrOp TIdent TCPar TPtVirg TIdent TOPar & TIdent TPtrOp TIdent TCPar TPtVirg TIdent TOPar & TIdent TPtrOp TIdent TDot TIdent TComma TInt TCPar TPtVirg TIdent TOPar & TIdent TPtrOp TIdent TDot TIdent TComma TInt TCPar TPtVirg TIdent TOPar & TIdent TPtrOp TIdent TCPar TPtVirg TIdent TOPar TIdent TCPar TPtVirg TIdent TOPar & TIdent TPtrOp TIdent TCPar TPtVirg TIdent TOPar & TIdent TPtrOp TIdent TCPar TPtVirg TIdent TOPar & TIdent TPtrOp TIdent TCPar TPtVirg TIdent TOPar TIdent TCPar TPtVirg
btrfs fix race between device replace and chunk allocation while iterating and copying extents from the source device the device replace code keeps adjusting a left cursor that is used to make sure that once we finish processing a device extent any future writes to extents from the corresponding block group will get into both the source and target devices this left cursor is also used for resuming the device replace operation at mount time however using this left cursor to decide whether writes go into both devices or only the source device is not enough to guarantee we dont miss copying extents into the target device there are two cases where the current approach fails the first one is related to when there are holes in the device and they get allocated for new block groups while the device replace operation is iterating the device extents more on this explained below the second one is that when that loop over the device extents finishes we start dellaloc wait for all ordered extents and then commit the current transaction we might have got new block groups allocated that are now using a device extent that has an offset greater then or equals to the value of the left cursor in which case writes to extents belonging to these new block groups will get issued only to the source device for the first case where the current approach of using a left cursor fails consider the source device currently has the following layout extent bg a hole unallocated space extent bg b while we are iterating the device extents from the source device using the commit root of the device tree the following happens cpu __number__ cpu __number__ are at transaction scrub_enumerate_chunks searches the device tree for extents belonging to the source device using the device trees commit root iteration finds extent belonging to block group a sets block group a to ro mode btrfs_inc_block_group_ro sets cursor left to which is scrub_chunk starts copies all allocated extents from block groups a stripe at source device into target device btrfs_alloc_chunk allocates device extent in the range from the source device for a new block group c extent allocated from block group c for a direct io buffered write or btree extent is written to perhaps in response to a writepages call from the vm or directly through direct io the write is made only against the source device and not against the target device because the extents offset is in the interval which is larger then the value of cursor_left scrub_chunks finishes updates left cursor from to btrfs_dec_block_group_ro sets block group a back to rw mode are still at transaction iteration finds extent belonging to block group b it did not find the new extent in the range for block group c because we are using the device trees commit root or even because the block groups items are not all yet inserted in the respective btrees that is the block group is still attached to some transaction handles new_bgs list and btrfs_create_pending_block_groups was not called yet against that transaction handle so the device extent items were not yet inserted into the devices tree are still at transaction so we end not copying anything from the newly allocated device extent from the source device to the target device so fix this by making __btrfs_map_block always redirect writes to the target device as well independently of the left cursors value with this change the left cursor is now used only for the purpose of tracking progress and allow a mount operation to resume a device replace	fs btrfs volumes Ttcons TIdent * TIdent = TIdent TPtrOp TIdent + TIdent TPtVirg Tkwd TOPar TIdent + TIdent TPtrOp TIdent <= TIdent TPtrOp TIdent TCPar Ttcons TIdent * TIdent = TIdent TPtrOp TIdent + TIdent TPtVirg TIdent TPtrOp TIdent = TIdent TPtVirg TIdent TPtrOp TIdent = TIdent TPtrOp TIdent TOCro TIdent TCCro TDot TIdent TPtVirg TIdent TPtrOp TIdent = TIdent TPtrOp TIdent TPtVirg TIdent TPtrOp TIdent TOCro TIdent TCCro = TIdent TPtVirg TIdent TPtrOp TIdent = TIdent TPtVirg TIdent TPtrOp TIdent = TIdent TPtrOp TIdent TOCro TIdent TCCro TDot TIdent TPtVirg TIdent TPtrOp TIdent = TIdent TPtrOp TIdent TPtVirg TIdent TPtrOp TIdent TOCro TIdent TCCro = TIdent TPtVirg TIdent ++ TPtVirg TIdent ++ TPtVirg TIdent ++ TPtVirg TIdent ++ TPtVirg
panic if kernel doesnt support x2apic but bios has enabled x2apic when kernel doesnt support x2apic but bios has enabled x2apic system may panic or hang without useful messages on the other hand its hard to dynamically disable x2apic when config_x86_x2apic is disabled so panic with a clear message in such a case now system panics as below when x2apic is disabled and interrupt remapping is enabled __float__ lapic pending interrupts after __number__ eoi __float__ __float__ kernel panic not syncing timer doesnt work through interrupt-remapped io-apic __float__ cpu __number__ pid __number__ comm not tainted __float__ hardware name intel corporation bios __float__ __address__ __address__ __address__ __number__ __float__ __address__ __address__ __address__ __number__ __float__ __number__ __address__ __address__ __address__ __float__ call trace __float__ __address__ __float__ __address__ __float__ __address__ __float__ __address__ __float__ __address__ __float__ __address__ __float__ __address__ __float__ __address__ __float__ __address__ __float__ __address__ __float__ __address__ __float__ end kernel panic not syncing timer doesnt work through interrupt-remapped io-apic system hangs as below when x2apic and interrupt remapping are both disabled __float__ pci __number__ system wakeup disabled by acpi __float__ pci __number__ system wakeup disabled by acpi __float__ pci __number__ system wakeup disabled by acpi __float__ pci __number__ system wakeup disabled by acpi __float__ pci __number__ enabling mpc irbnce __float__ pci __number__ intel pch root port acs workaround enabled __float__ pci __number__ system wakeup disabled by acpi __float__ pci __number__ enabling mpc irbnce __float__ pci __number__ intel pch root port acs workaround enabled __float__ pci __number__ system wakeup disabled by acpi __float__ pci __number__ system wakeup disabled by acpi __float__ acpiphp slot __number__ registered __float__ pci __number__ pci bridge to bus __number__ __float__ acpiphp slot __number__ registered with this patch applied the system panics in both cases with a proper panic message link	arch x86 kernel apic apic Tkwd TOPar TBang TIdent TOPar TIdent TCPar TCPar TIdent TIdent TPtVirg TIdent TOPar TIdent TComma TIdent TCPar TPtVirg Tkwd TOPar TIdent & TIdent TCPar TIdent TOPar TString TCPar TPtVirg
arm l2c add support for the property corelink level __number__ cache controller l2c-310 p section shareable attribute states the default behavior of the cache controller with respect to the shareable attribute is to transform normal memory non-cacheable transactions into cacheable no allocate for reads write through no write allocate for writes depending on the system architecture this may cause memory corruption in the presence of bus mastering devices ohci to avoid such corruption the default behavior can be disabled by setting the shared override bit in the auxiliary control register currently the shared override bit can be set only using c code by calling l2x0_init directly which is deprecated by the bit in the fields but using values differing from is also deprecated hence add support for an device tree property for the l2c device node by specifying this property affected systems can indicate that non-cacheable transactions must not be transformed then its up to the os to decide the current behavior is to set the shared attribute override enable bit as there may exist kernel linear mappings and cacheable aliases for the dma buffers even if cma is enabled see also commit arm vexpress set bit __number__ in the pl310 cache controller auxctlr register clearing bit __number__ in the pl310 auxiliary control register shared attribute override enable has the side effect of transforming normal shared non-cacheable reads into cacheable no-allocate reads coherent dma buffers in linux always have a cacheable alias via the kernel linear mapping and the processor can speculatively load cache lines into the pl310 controller with bit __number__ cleared non-cacheable reads would unexpectedly hit such cache lines leading to buffer corruption	arch arm mm cache-l2x0 Tkwd TOPar TIdent TOPar TIdent TComma TString TCPar TCPar * TIdent |= TIdent TPtVirg * TIdent &= TTilde TIdent TPtVirg
drivers net cpsw fix broken loop condition in switch mode drivers net cpsw fix buggy loop condition accidentally fixed a loop comparison in too many places while fixing a real bug it was correct to fix the dual_emac mode section since there i is used as an index into which is a __number__ based array however the other two changes which are only used in switch mode are wrong since there i is actually the ale port number and port __number__ is the host port while port __number__ and up are the slave ports putting the loop condition back in the switch mode section fixes it a comment has been added to point out the intent clearly to avoid future confusion also a comment is fixed that said the opposite of what was actually happening	drivers net ethernet ti cpsw Tkwd TOPar TIdent = TInt TPtVirg TIdent <= TIdent TPtrOp TIdent TDot TIdent TPtVirg TIdent ++ TCPar Tkwd TOPar TIdent = TInt TPtVirg TIdent < TIdent TPtrOp TIdent TDot TIdent TPtVirg TIdent ++ TCPar Tkwd TOPar TIdent = TInt TPtVirg TIdent <= TIdent TPtrOp TIdent TDot TIdent TPtVirg TIdent ++ TCPar Tkwd TOPar TIdent = TInt TPtVirg TIdent < TIdent TPtrOp TIdent TDot TIdent TPtVirg TIdent ++ TCPar
usb qcserial adding sierra wireless devices the qmi mode of the sierra wireless mc7710 is close to a gobi device and also identified as one by the windows drivers provided by sony the serial interfaces are the same as for any other gobi module but the usb interface layout is different __number__ also present in bootloader mode __number__ nmea __number__ at-capable modem port __number__ __number__ not always present __number__ not always present note in particular that the nmea and at ports are reversed compared to a gobi device and that the dm port appears as a qdl port in bootloader mode using the same device id the sony driver also document two new devices with standard gobi layout having a qdl mode adding these as well lenovo windows drivers document the usb interface layout for a few additional sierra wireless devices adding these while at it mc7770 with standard gobi layout mc7700 with the same layout as mc7710 mc7750 with the same layout as mc7710 em7700 with the same layout as mc7710	drivers usb serial qcserial Tvis Tlifetime Ttcons TIdent TIdent TOCro TCCro = TOBrace TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TCBrace TComma TCBrace TPtVirg
dmaengine at_xdmac fix false condition for memset_sg transfers the code was not in agreement with the comments	drivers dma at_xdmac Tkwd TOPar TOPar TIdent == TOPar TIdent - TInt TCPar TCPar && TIdent TOPar TIdent TCPar == TIdent TOPar TIdent TCPar TCPar Tkwd TOPar TOPar TIdent == TOPar TIdent - TInt TCPar TCPar && TIdent TOPar TIdent TCPar == TIdent TOPar TIdent TCPar TCPar
scsi_transport_sas remove check for sas expander when querying ids dell server backplanes can report ids without an expander present this patch allows the ids to be propagaged to	drivers scsi scsi_transport_sas Tkwd TOPar TIdent TOPar TIdent TCPar TCPar Tkwd - TIdent TPtVirg Tkwd TOPar TIdent TOPar TIdent TCPar TCPar Tkwd - TIdent TPtVirg
btrfs fix directory inconsistency after fsync log replay if we have an inode file with a link count greater than __number__ remove one of its hard links fsync the inode power and then replay the fsync log on the next mount we end up getting the parent directorys metadata inconsistent its i_size still reflects the deleted hard link and has dangling index entries with no matching inode reference entries this prevents the directory from ever being deletable as its i_size can never decrease to btrfs_empty_dir_size even if all of its children inodes are deleted and the dangling index entries can never be removed as they point to an inode that does not exist anymore this is easy to reproduce with the following excerpt from the test case for xfstests that i just made _scratch_mkfs _init_flakey _mount_flakey create a test file with __number__ hard links in the same directory mkdir echo hello world ln make sure all metadata and data are durably persisted sync now remove one of the hard links and fsync the inode rm fsync simulate a loss this makes sure the next mount will see an fsync log and will replay that log _load_flakey_table _unmount_flakey _load_flakey_table _mount_flakey remove the last hard link of the file and attempt to remove its parent directory this failed in btrfs because the fsync log and replay code didnt decrement the parent directorys i_size and left dangling directory index entries this made the btrfs rmdir implementation always fail with the error the dangling directory index entries were visible to user space but it was impossible to do anything on them unlink open read write stat etc because the inode they pointed to did not exist anymore the parent directorys metadata inconsistency stale index entries was also detected by btrfs fsck tool which is run automatically by the fstests framework when the test finishes the error message reported by fsck was root __number__ inode __number__ errors __number__ no inode item link count wrong unresolved ref dir __number__ index __number__ namelen __number__ name bar filetype __number__ errors __number__ no inode ref rm rmdir rmdir to fix this just make sure that after an unlink if the inode is fsynced he parent inode is fully logged in the fsync log a test case for xfstests follows soon	fs btrfs tree-log Tlifetime Ttcons TIdent * Tlifetime TIdent = TIdent TPtVirg Tlifetime TIdent TIdent = TOPar TIdent TOPar TIdent TCPar TPtrOp TIdent > TIdent TCPar TPtVirg TIdent = TIdent TPtVirg Tkwd TOPar TIdent && TIdent == TIdent TCPar TIdent = TIdent TPtVirg TIdent = TIdent TPtVirg Tkwd TOPar TIdent TOPar TIdent TCPar TPtrOp TIdent > TIdent TPtrOp TIdent TPtrOp TIdent || TIdent == TIdent TCPar Tkwd TOPar TIdent TOPar TIdent TCPar TPtrOp TIdent > TIdent TPtrOp TIdent TPtrOp TIdent TCPar
bluetooth btusb sort usb_device entries for marvell by vendor id new entries to the usb device table should be sorted by usb vendor id fix the recent entry fro marvell devices	drivers bluetooth btusb Tvis Tlifetime Ttcons TIdent TIdent TOCro TCCro = TOBrace TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TDot TIdent = TIdent TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TDot TIdent = TIdent TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TDot TIdent = TIdent TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TDot TIdent = TIdent TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TDot TIdent = TIdent TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TDot TIdent = TIdent TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TDot TIdent = TIdent TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TDot TIdent = TIdent TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TDot TIdent = TIdent TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TDot TIdent = TIdent TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TDot TIdent = TIdent TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TDot TIdent = TIdent TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TDot TIdent = TIdent TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TDot TIdent = TIdent TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TDot TIdent = TIdent TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TDot TIdent = TIdent TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TDot TIdent = TIdent TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TDot TIdent = TIdent TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TDot TIdent = TIdent TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TDot TIdent = TIdent TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TDot TIdent = TIdent TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TDot TIdent = TIdent TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TDot TIdent = TIdent TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TDot TIdent = TIdent TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TDot TIdent = TIdent TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TDot TIdent = TIdent TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TDot TIdent = TIdent TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TDot TIdent = TIdent TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TDot TIdent = TIdent TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TDot TIdent = TIdent TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TDot TIdent = TIdent TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TDot TIdent = TIdent TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TDot TIdent = TIdent TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TDot TIdent = TIdent TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TDot TIdent = TIdent TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TDot TIdent = TIdent TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TDot TIdent = TIdent TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TDot TIdent = TIdent TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TDot TIdent = TIdent TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TDot TIdent = TIdent TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TDot TIdent = TIdent TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TDot TIdent = TIdent TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TDot TIdent = TIdent TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TDot TIdent = TIdent TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TDot TIdent = TIdent TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TDot TIdent = TIdent TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TDot TIdent = TIdent TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TDot TIdent = TIdent TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TDot TIdent = TIdent TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TDot TIdent = TIdent TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TDot TIdent = TIdent TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TDot TIdent = TIdent TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TDot TIdent = TIdent TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TDot TIdent = TIdent TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TDot TIdent = TIdent TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TDot TIdent = TIdent TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TDot TIdent = TIdent TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TDot TIdent = TIdent TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TDot TIdent = TIdent TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TDot TIdent = TIdent TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TDot TIdent = TIdent TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TDot TIdent = TIdent TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TDot TIdent = TIdent TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TDot TIdent = TIdent TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TDot TIdent = TIdent TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TDot TIdent = TIdent TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TDot TIdent = TIdent TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TDot TIdent = TIdent TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TDot TIdent = TIdent TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TDot TIdent = TIdent | TIdent TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TDot TIdent = TIdent | TIdent TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TDot TIdent = TIdent TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TDot TIdent = TIdent TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TDot TIdent = TIdent TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TDot TIdent = TIdent TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TDot TIdent = TIdent TComma TCBrace TComma TOBrace TCBrace TComma TCBrace TPtVirg Tvis Tlifetime Ttcons TIdent TIdent TOCro TCCro = TOBrace TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TDot TIdent = TIdent TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TDot TIdent = TIdent TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TDot TIdent = TIdent TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TDot TIdent = TIdent TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TDot TIdent = TIdent TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TDot TIdent = TIdent TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TDot TIdent = TIdent TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TDot TIdent = TIdent TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TDot TIdent = TIdent TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TDot TIdent = TIdent TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TDot TIdent = TIdent TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TDot TIdent = TIdent TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TDot TIdent = TIdent TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TDot TIdent = TIdent TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TDot TIdent = TIdent TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TDot TIdent = TIdent TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TDot TIdent = TIdent TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TDot TIdent = TIdent TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TDot TIdent = TIdent TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TDot TIdent = TIdent TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TDot TIdent = TIdent TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TDot TIdent = TIdent TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TDot TIdent = TIdent TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TDot TIdent = TIdent TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TDot TIdent = TIdent TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TDot TIdent = TIdent TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TDot TIdent = TIdent TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TDot TIdent = TIdent TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TDot TIdent = TIdent TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TDot TIdent = TIdent TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TDot TIdent = TIdent TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TDot TIdent = TIdent TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TDot TIdent = TIdent TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TDot TIdent = TIdent TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TDot TIdent = TIdent TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TDot TIdent = TIdent TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TDot TIdent = TIdent TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TDot TIdent = TIdent TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TDot TIdent = TIdent TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TDot TIdent = TIdent TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TDot TIdent = TIdent TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TDot TIdent = TIdent TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TDot TIdent = TIdent TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TDot TIdent = TIdent TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TDot TIdent = TIdent TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TDot TIdent = TIdent TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TDot TIdent = TIdent TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TDot TIdent = TIdent TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TDot TIdent = TIdent TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TDot TIdent = TIdent TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TDot TIdent = TIdent TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TDot TIdent = TIdent TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TDot TIdent = TIdent TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TDot TIdent = TIdent TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TDot TIdent = TIdent TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TDot TIdent = TIdent TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TDot TIdent = TIdent TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TDot TIdent = TIdent TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TDot TIdent = TIdent TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TDot TIdent = TIdent TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TDot TIdent = TIdent TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TDot TIdent = TIdent TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TDot TIdent = TIdent TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TDot TIdent = TIdent TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TDot TIdent = TIdent TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TDot TIdent = TIdent TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TDot TIdent = TIdent TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TDot TIdent = TIdent TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TDot TIdent = TIdent TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TDot TIdent = TIdent | TIdent TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TDot TIdent = TIdent | TIdent TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TDot TIdent = TIdent TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TDot TIdent = TIdent TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TDot TIdent = TIdent TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TDot TIdent = TIdent TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TDot TIdent = TIdent TComma TCBrace TComma TOBrace TCBrace TComma TCBrace TPtVirg
fix divwu instruction opcode currently divwu stands for divw opcode __number__ divwu d6 divw use the divw opcode for divwu	arch powerpc include asm ppc-opcode TDefine TIdent TInt TDefine TIdent TInt
qmi_wwan add various novatel gobi1k ids found in the windows inf files while investigating the usb-1000 device the usb-1000 is verified as a gobi1k device and works with qmi after loading appropriate firmware	drivers net usb qmi_wwan Tvis Tlifetime Ttcons TIdent TIdent TOCro TCCro = TOBrace TOBrace TIdent TOPar TIdent TComma TIdent TComma TInt TComma TInt TCPar TComma TDot TIdent = TOPar Tsign Ttype TCPar & TIdent TComma TCBrace TComma TOBrace TIdent TOPar TIdent TComma TIdent TComma TInt TComma TInt TCPar TComma TDot TIdent = TOPar Tsign Ttype TCPar & TIdent TComma TCBrace TComma TOBrace TIdent TOPar TIdent TComma TIdent TComma TInt TComma TInt TCPar TComma TDot TIdent = TOPar Tsign Ttype TCPar & TIdent TComma TCBrace TComma TOBrace TIdent TOPar TIdent TComma TIdent TComma TInt TComma TInt TCPar TComma TDot TIdent = TOPar Tsign Ttype TCPar & TIdent TComma TCBrace TComma TOBrace TIdent TOPar TIdent TComma TIdent TComma TInt TComma TInt TCPar TComma TDot TIdent = TOPar Tsign Ttype TCPar & TIdent TComma TCBrace TComma TOBrace TIdent TOPar TIdent TComma TIdent TComma TInt TComma TInt TCPar TComma TDot TIdent = TOPar Tsign Ttype TCPar & TIdent TComma TCBrace TComma TOBrace TIdent TOPar TIdent TComma TIdent TComma TInt TComma TInt TCPar TComma TDot TIdent = TOPar Tsign Ttype TCPar & TIdent TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TIdent TComma TInt TComma TInt TCPar TComma TDot TIdent = TOPar Tsign Ttype TCPar & TIdent TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TIdent TComma TInt TComma TInt TCPar TComma TDot TIdent = TOPar Tsign Ttype TCPar & TIdent TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TComma TIdent TComma TIdent TComma TIdent TCPar TComma TDot TIdent = TOPar Tsign Ttype TCPar & TIdent TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TComma TIdent TComma TIdent TComma TIdent TCPar TComma TDot TIdent = TOPar Tsign Ttype TCPar & TIdent TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TComma TIdent TComma TIdent TComma TIdent TCPar TComma TDot TIdent = TOPar Tsign Ttype TCPar & TIdent TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TComma TIdent TComma TIdent TComma TIdent TCPar TComma TDot TIdent = TOPar Tsign Ttype TCPar & TIdent TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TComma TIdent TComma TIdent TComma TIdent TCPar TComma TDot TIdent = TOPar Tsign Ttype TCPar & TIdent TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TComma TIdent TComma TIdent TComma TIdent TCPar TComma TDot TIdent = TOPar Tsign Ttype TCPar & TIdent TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TCBrace TComma TCBrace TPtVirg Tvis Tlifetime Ttcons TIdent TIdent TOCro TCCro = TOBrace TOBrace TIdent TOPar TIdent TComma TIdent TComma TInt TComma TInt TCPar TComma TDot TIdent = TOPar Tsign Ttype TCPar & TIdent TComma TCBrace TComma TOBrace TIdent TOPar TIdent TComma TIdent TComma TInt TComma TInt TCPar TComma TDot TIdent = TOPar Tsign Ttype TCPar & TIdent TComma TCBrace TComma TOBrace TIdent TOPar TIdent TComma TIdent TComma TInt TComma TInt TCPar TComma TDot TIdent = TOPar Tsign Ttype TCPar & TIdent TComma TCBrace TComma TOBrace TIdent TOPar TIdent TComma TIdent TComma TInt TComma TInt TCPar TComma TDot TIdent = TOPar Tsign Ttype TCPar & TIdent TComma TCBrace TComma TOBrace TIdent TOPar TIdent TComma TIdent TComma TInt TComma TInt TCPar TComma TDot TIdent = TOPar Tsign Ttype TCPar & TIdent TComma TCBrace TComma TOBrace TIdent TOPar TIdent TComma TIdent TComma TInt TComma TInt TCPar TComma TDot TIdent = TOPar Tsign Ttype TCPar & TIdent TComma TCBrace TComma TOBrace TIdent TOPar TIdent TComma TIdent TComma TInt TComma TInt TCPar TComma TDot TIdent = TOPar Tsign Ttype TCPar & TIdent TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TIdent TComma TInt TComma TInt TCPar TComma TDot TIdent = TOPar Tsign Ttype TCPar & TIdent TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TIdent TComma TInt TComma TInt TCPar TComma TDot TIdent = TOPar Tsign Ttype TCPar & TIdent TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TComma TIdent TComma TIdent TComma TIdent TCPar TComma TDot TIdent = TOPar Tsign Ttype TCPar & TIdent TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TComma TIdent TComma TIdent TComma TIdent TCPar TComma TDot TIdent = TOPar Tsign Ttype TCPar & TIdent TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TComma TIdent TComma TIdent TComma TIdent TCPar TComma TDot TIdent = TOPar Tsign Ttype TCPar & TIdent TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TComma TIdent TComma TIdent TComma TIdent TCPar TComma TDot TIdent = TOPar Tsign Ttype TCPar & TIdent TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TComma TIdent TComma TIdent TComma TIdent TCPar TComma TDot TIdent = TOPar Tsign Ttype TCPar & TIdent TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TComma TIdent TComma TIdent TComma TIdent TCPar TComma TDot TIdent = TOPar Tsign Ttype TCPar & TIdent TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TIdent TOPar TInt TComma TInt TCPar TComma TCBrace TComma TOBrace TCBrace TComma TCBrace TPtVirg
ocfs2 o2net dont shutdown connection when idle timeout this patch series is to fix a possible message lost bug in ocfs2 when network go bad this bug will cause ocfs2 hung forever even network become good again the messages may lost in this case after the tcp connection is established between two nodes an idle timer will be set to check its state periodically if no messages are received during this time idle timer will timeout it will shutdown the connection and try to reconnect so pending messages in tcp queues will be lost this messages may be from dlm dlm may get hung in this case this may cause the whole ocfs2 cluster hung this is very possible to happen when network state goes bad do the reconnect is useless it will fail if network state is still bad just waiting there for network recovering may be a good idea it will not lost messages and some node will be fenced until cluster goes into split-brain state for this case tcp user timeout is used to override the tcp retransmit timeout it will timeout after __number__ days user should have notice this through the provided log and fix the network if they dont ocfs2 will fall back to original reconnect way this patch of __number__ some messages in the tcp queue maybe lost if we shutdown the connection and reconnect when idle timeout if packets lost and reconnect success then the ocfs2 cluster maybe hung to fix this we can leave the connection there and do the fence decision when idle timeout if network recover before fence dicision is made the connection survive without lost any messages this bug can be saw when network state go bad it may cause ocfs2 hung forever if some packets lost with this fix ocfs2 will recover from hung if network becomes good again	fs ocfs2 cluster tcp TIdent TOPar TIdent TString TIdent TString TString TComma TIdent TOPar TIdent TCPar TComma TIdent / TInt TComma TIdent % TInt TCPar TPtVirg TIdent TOPar TIdent TString TIdent TString TString TComma TIdent TOPar TIdent TCPar TComma TIdent / TInt TComma TIdent % TInt TCPar TPtVirg TIdent TOPar TIdent TOPar TIdent TCPar TCPar TPtVirg TIdent TOPar TIdent TComma & TIdent TPtrOp TIdent TComma TIdent TOPar TIdent TCPar TCPar TPtVirg TIdent TOPar TIdent TCPar TPtVirg TIdent TOPar TIdent TComma & TIdent TPtrOp TIdent TCPar TPtVirg Ttcons TIdent * TIdent = TIdent TOPar TIdent TPtrOp TIdent TPtrOp TIdent TCPar TPtVirg Tkwd TOPar TIdent TOPar & TIdent TPtrOp TIdent TCPar TCPar TIdent TOPar TIdent TOPar TIdent TCPar TCPar TPtVirg TIdent TOPar & TIdent TPtrOp TIdent TCPar TPtVirg TIdent TOPar & TIdent TPtrOp TIdent TComma TInt TCPar TPtVirg
usb ehci-fsl fix kernel crash on mpc5121e since commit fix bug of kernel hang when initializing usb the kernel crashes on mpc5121e mpc5121e doesnt have system interface registers accessing this register address space cause the machine check exception and a kernel crash __float__ ehci_hcd usb __float__ enhanced host controller ehci driver __float__ fsl-ehci freescale on-chip ehci host controller __float__ fsl-ehci new usb bus registered assigned bus number __number__ __float__ machine check in kernel mode __float__ caused by from transfer error ack signal __float__ oops machine check sig __number__ __float__ mpc5121 ads __float__ modules linked in __float__ nip lr ctr __number__ __float__ regs trap __number__ not tainted __float__ msr __number__ cr __number__ xer __number__ __float__ task df8340001 swapper thread __float__ gpr00 __number__ __number__ __number__ __number__ __number__ __float__ gpr08 __number__ __number__ __number__ __number__ __number__ __float__ gpr16 __number__ __number__ __number__ __float__ gpr24 __number__ __number__ __number__ __float__ nip __float__ lr __float__ call trace __float__ unreliable __float__ __float__ __float__ __float__ __float__ __float__ __float__ __float__ __float__ __float__ __float__ __float__ __float__ __float__ __float__ __float__ __float__ __float__ __float__ __float__ __float__ __float__ __float__ __float__ instruction dump __float__ __number__ __address__ __float__ __number__ __number__ __number__ __float__ end trace __float__ __float__ kernel panic not syncing attempted to kill init __number__ __float__ __float__ rebooting in __number__ check flag before accessing system interface registers	drivers usb host ehci-fsl Ttcons TIdent * TIdent TPtVirg TIdent = TIdent TPtrOp TIdent TDot TIdent TPtrOp TIdent TPtVirg Tkwd TOPar TIdent TPtrOp TIdent TCPar TIdent TOPar TIdent + TIdent TComma TIdent TCPar TPtVirg TIdent TOPar TIdent + TIdent TComma TIdent TCPar TPtVirg
alsa hda add dock support for thinkpad t431s add a string lenovo-dock for thinkpad t431s to allow sound in docking station tested on lenovo t431s with thinkpad mini dock plus series __number__	sound pci hda patch_realtek Tvis Tlifetime Ttcons TIdent TIdent TOCro TCCro = TOBrace TIdent TOPar TInt TComma TInt TComma TString TComma TIdent TCPar TComma TIdent TOPar TInt TComma TInt TComma TString TComma TIdent TCPar TComma TIdent TOPar TInt TComma TInt TComma TString TComma TIdent TCPar TComma TIdent TOPar TInt TComma TInt TComma TString TComma TIdent TCPar TComma TIdent TOPar TInt TComma TInt TComma TString TComma TIdent TCPar TComma TIdent TOPar TInt TComma TInt TComma TString TComma TIdent TCPar TComma TIdent TOPar TInt TComma TInt TComma TString TComma TIdent TCPar TComma TIdent TOPar TInt TComma TInt TComma TString TComma TIdent TCPar TComma TIdent TOPar TInt TComma TInt TComma TString TComma TIdent TCPar TComma TIdent TOPar TInt TComma TInt TComma TString TComma TIdent TCPar TComma TIdent TOPar TInt TComma TInt TComma TString TComma TIdent TCPar TComma TIdent TOPar TInt TComma TInt TComma TString TComma TIdent TCPar TComma TIdent TOPar TInt TComma TInt TComma TString TComma TIdent TCPar TComma TIdent TOPar TInt TComma TInt TComma TString TComma TIdent TCPar TComma TIdent TOPar TInt TComma TInt TComma TString TComma TIdent TCPar TComma TIdent TOPar TInt TComma TInt TComma TString TComma TIdent TCPar TComma TIdent TOPar TInt TComma TInt TComma TString TComma TIdent TCPar TComma TIdent TOPar TInt TComma TInt TComma TString TComma TIdent TCPar TComma TIdent TOPar TInt TComma TInt TComma TString TComma TIdent TCPar TComma TIdent TOPar TInt TComma TInt TComma TString TComma TIdent TCPar TComma TIdent TOPar TInt TComma TInt TComma TString TComma TIdent TCPar TComma TIdent TOPar TInt TComma TInt TComma TString TComma TIdent TCPar TComma TIdent TOPar TInt TComma TInt TComma TString TComma TIdent TCPar TComma TIdent TOPar TInt TComma TInt TComma TString TComma TIdent TCPar TComma TIdent TOPar TInt TComma TInt TComma TString TComma TIdent TCPar TComma TIdent TOPar TInt TComma TInt TComma TString TComma TIdent TCPar TComma TIdent TOPar TInt TComma TInt TComma TString TComma TIdent TCPar TComma TIdent TOPar TInt TComma TString TComma TIdent TCPar TComma TIdent TOPar TInt TComma TInt TComma TString TComma TIdent TCPar TComma TIdent TOPar TInt TComma TInt TComma TString TComma TIdent TCPar TComma TIdent TOPar TInt TComma TInt TComma TString TComma TIdent TCPar TComma TIdent TOPar TInt TComma TInt TComma TString TComma TIdent TCPar TComma TIdent TOPar TInt TComma TInt TComma TString TComma TIdent TCPar TComma TIdent TOPar TInt TComma TInt TComma TString TComma TIdent TCPar TComma TIdent TOPar TInt TComma TInt TComma TString TComma TIdent TCPar TComma TIdent TOPar TInt TComma TInt TComma TString TComma TIdent TCPar TComma TIdent TOPar TInt TComma TInt TComma TString TComma TIdent TCPar TComma TIdent TOPar TInt TComma TInt TComma TString TComma TIdent TCPar TComma TIdent TOPar TInt TComma TInt TComma TString TComma TIdent TCPar TComma TIdent TOPar TInt TComma TInt TComma TString TComma TIdent TCPar TComma TIdent TOPar TInt TComma TInt TComma TString TComma TIdent TCPar TComma TIdent TOPar TInt TComma TInt TComma TString TComma TIdent TCPar TComma TIdent TOPar TInt TComma TInt TComma TString TComma TIdent TCPar TComma TIdent TOPar TInt TComma TInt TComma TString TComma TIdent TCPar TComma TIdent TOPar TInt TComma TString TComma TIdent TCPar TComma TIdent TOPar TInt TComma TInt TComma TString TComma TIdent TCPar TComma TIdent TOPar TInt TComma TInt TComma TString TComma TIdent TCPar TComma TIdent TOPar TInt TComma TInt TComma TString TComma TIdent TCPar TComma TIdent TOPar TInt TComma TInt TComma TString TComma TIdent TCPar TComma TIdent TOPar TInt TComma TString TComma TIdent TCPar TComma TIdent TOPar TInt TComma TInt TComma TString TComma TIdent TCPar TComma TIdent TOPar TInt TComma TInt TComma TString TComma TIdent TCPar TComma TIdent TOPar TInt TComma TInt TComma TString TComma TIdent TCPar TComma TIdent TOPar TInt TComma TInt TComma TString TComma TIdent TCPar TComma TIdent TOPar TInt TComma TInt TComma TString TComma TIdent TCPar TComma TIdent TOPar TInt TComma TInt TComma TString TComma TIdent TCPar TComma TIdent TOPar TInt TComma TInt TComma TString TComma TIdent TCPar TComma TIdent TOPar TInt TComma TInt TComma TString TComma TIdent TCPar TComma TIdent TOPar TInt TComma TInt TComma TString TComma TIdent TCPar TComma TIdent TOPar TInt TComma TInt TComma TString TComma TIdent TCPar TComma TIdent TOPar TInt TComma TInt TComma TString TComma TIdent TCPar TComma TIdent TOPar TInt TComma TInt TComma TString TComma TIdent TCPar TComma TIdent TOPar TInt TComma TInt TComma TString TComma TIdent TCPar TComma TIdent TOPar TInt TComma TInt TComma TString TComma TIdent TCPar TComma TOBrace TCBrace TComma TCBrace TPtVirg
net fec dont clear ipv6 header checksum field when ip accelerator enable the commit net fec enable ip header hardware checksum enable hw ip header checksum for ipv4 and ipv6 which causes ipv6 cannot work the issue is reported by russell king for fec ip header checksum function insert ip header checksum this iins bit is written by the user if set ip accelerator calculates the ip header checksum and overwrites the iins corresponding header field with the calculated value the checksum field must be cleared by user otherwise the checksum always is so the previous patch clear ip header checksum field regardless of ip frame type in fact ip hw detect the packet as ipv6 type even if the iins bit is set the ip accelerator is not triggered to calculates ipv6 header checksum because ipv6 frame format dont have checksum so this results in the ipv6 frame being corrupted the patch just add software detect the current packet type if it is ipv6 frame it dont clear ip header checksum field	drivers net ethernet freescale fec_main Tvis TIdent TIdent TOPar Ttcons TIdent * TIdent TCPar Tkwd TIdent TPtrOp TIdent == TIdent TOPar TIdent TCPar && TIdent TOPar TIdent TCPar TPtrOp TIdent == TInt TPtVirg Tkwd TOPar TIdent TOPar TIdent TCPar TCPar TIdent TOPar TIdent TCPar TPtrOp TIdent = TInt TPtVirg TIdent TOPar TIdent TCPar TPtrOp TIdent = TInt TPtVirg
btrfs fix crash when mounting raid5 btrfs with missing disks the reproducer is d1 d2 d3 d2 d3 mount d1 __float__ cut here __float__ kernel bug at __float__ rip __address__ __address__ __float__ call trace __float__ __address__ __float__ __address__ __float__ __address__ __float__ __address__ __float__ __address__ __float__ __address__ __float__ __address__ __float__ __address__ __float__ __address__ __float__ __address__ __float__ __address__ __float__ __address__ __float__ __address__ __float__ __address__ its because that we miscalculate so that it doesnt reach maximum of tolerable errors while it should have	fs btrfs raid56 Tkwd TOPar TIdent TPtrOp TIdent == TIdent || TIdent TPtrOp TIdent == TIdent TCPar TIdent TOPar & TIdent TPtrOp TIdent TPtrOp TIdent TCPar TPtVirg Tkwd TOPar TIdent TPtrOp TIdent == TIdent || TIdent TPtrOp TIdent == TIdent TCPar
l2tp fix race in l2tp_recv_dequeue misha labjuk reported panics occurring in l2tp_recv_dequeue if we release we must not keep a dangling pointer tmp since another thread could manipulate reorder_q instead we must restart the scan at beginning of list	net l2tp l2tp_core TIdent TDotDot TIdent TOPar & TIdent TPtrOp TIdent TDot TIdent TCPar TPtVirg Tkwd TIdent TPtVirg TIdent TOPar & TIdent TPtrOp TIdent TDot TIdent TCPar TPtVirg
block fix regression where bio_integrity_process uses wrong bio_vec iterator bio integrity handling is broken on a system with lvm layered atop a scsi drive because device mapper clones the bio modifies the clone and sends the clone to the lower layers for processing however the clone bio has bi_vcnt __number__ which means that when the sd driver calls bio_integrity_process to attach dix data the for_each_segment_all call which uses bi_vcnt returns immediately and random garbage is sent to the disk on a disk write the disk of course returns an error therefore teach bio_integrity_process to use bio_for_each_segment to iterate the bio_vecs since the per-bio iterator tracks which bio_vecs are associated with that particular bio the integrity handling code is effectively part of the driver its not the bio owner so it must use the correct iterator function v2 fix a compiler warning about abandoned local variables this patch supersedes block bio_integrity_process uses wrong bio_vec iterator patch applies against	block bio-integrity Ttcons TIdent TIdent TPtVirg Ttcons TIdent TIdent TPtVirg Ttcons TIdent * TIdent TPtVirg Tsign Ttype TIdent = TInt TPtVirg Tsign Ttype TIdent TComma TIdent = TInt TPtVirg TIdent TOPar TIdent TComma TIdent TComma TIdent TCPar Ttype * TIdent = TIdent TOPar TIdent TDot TIdent TCPar TPtVirg TIdent TOPar TIdent TComma TIdent TComma TIdent TCPar Ttype * TIdent = TIdent TOPar TIdent TPtrOp TIdent TCPar TPtVirg TIdent TDot TIdent = TIdent + TIdent TDot TIdent TPtVirg TIdent TDot TIdent = TIdent TDot TIdent TPtVirg TIdent TDot TIdent = TIdent + TIdent TPtrOp TIdent TPtVirg TIdent TDot TIdent = TIdent TPtrOp TIdent TPtVirg
only load initrd above on second try mantas found that after commit support initrd loaded above the kernel freezes at the earliest possible moment when trying to boot via uefi on asus laptop revert to old way to load initrd under on first try second try will use above buffer when initrd is too big and does not fit under the cause of the freeze appears to be a firmware bug when reading file data into buffers above though the exact reason is unknown mantas reports that the hang can be avoid if the file size is a multiple of __number__ bytes but ive seen some asus firmware simply corrupting the file data rather than freezing laszlo fixed an issue in the upstream edk2 diskio code in aug __number__ which may possibly be related commit fix pointer of overrun transfer whatever the cause its unlikely that a fix will be forthcoming from the vendor hence the workaround matt	arch x86 boot compressed eboot Tsign Ttype TIdent TPtVirg Tkwd TOPar TIdent TPtrOp TIdent & TIdent TCPar TIdent = - TInt TPtVirg TIdent = TIdent TPtrOp TIdent TPtVirg TIdent = TIdent TOPar TIdent TComma TIdent TComma TOPar Ttype * TCPar TOPar Tsign Ttype TCPar TIdent TPtrOp TIdent TComma TString TComma TIdent TPtrOp TIdent TComma & TIdent TComma & TIdent TCPar TPtVirg Tkwd TOPar TIdent != TIdent && TIdent TPtrOp TIdent & TIdent TCPar TIdent TOPar TIdent TComma TString TCPar TPtVirg TIdent = TIdent TOPar TIdent TComma TIdent TComma TOPar Ttype * TCPar TOPar Tsign Ttype TCPar TIdent TPtrOp TIdent TComma TString TComma - TInt TComma & TIdent TComma & TIdent TCPar TPtVirg TIdent = TIdent TOPar TIdent TComma TIdent TComma TOPar Ttype * TCPar TOPar Tsign Ttype TCPar TIdent TPtrOp TIdent TComma TString TComma TIdent TComma & TIdent TComma & TIdent TCPar TPtVirg
aio fix use-after-free in aio_migratepage dmitry vyukov managed to trigger a case where aio_migratepage can cause a use-after-free during teardown of the aio ring buffers mapping this turns out to be caused by access to the ioctxs ring_pages via the migratepage operation which was not being protected by any locks during ioctx freeing use the address_spaces private_lock to protect use and updates of the mappings private_data and make ioctx teardown unlink the ioctx from the address space	fs aio Tvis Ttype TIdent TOPar Ttcons TIdent * TIdent TCPar Ttcons TIdent * TIdent = TIdent TPtrOp TIdent TPtVirg Tkwd TOPar TIdent TCPar TIdent TOPar TIdent TPtrOp TIdent TComma TInt TCPar TPtVirg TIdent TOPar & TIdent TPtrOp TIdent TPtrOp TIdent TPtrOp TIdent TCPar TPtVirg TIdent TPtrOp TIdent TPtrOp TIdent TPtrOp TIdent = TIdent TPtVirg TIdent TPtrOp TIdent = TIdent TPtVirg TIdent TOPar & TIdent TPtrOp TIdent TPtrOp TIdent TPtrOp TIdent TCPar TPtVirg TIdent TOPar TIdent TCPar TPtVirg Ttcons TIdent * TIdent = TIdent TPtrOp TIdent TPtVirg TIdent TOPar TIdent TCPar TPtVirg Tkwd TOPar TIdent TCPar TIdent TOPar TIdent TPtrOp TIdent TComma TInt TCPar TPtVirg TIdent TOPar TIdent TCPar TPtVirg TIdent TPtrOp TIdent = TIdent TPtVirg Ttcons TIdent * TIdent TPtVirg Ttcons TIdent * TIdent = TIdent TPtrOp TIdent TPtVirg Tsign TIdent = TIdent TPtrOp TIdent TPtVirg TIdent TOPar & TIdent TPtrOp TIdent TCPar TPtVirg TIdent = TIdent TPtrOp TIdent TPtVirg Tkwd TOPar TIdent TCPar TIdent TIdent TPtVirg TIdent TOPar & TIdent TPtrOp TIdent TComma TIdent TCPar TPtVirg TIdent TOPar TIdent TComma TIdent TCPar TPtVirg TIdent = TIdent TPtrOp TIdent TPtVirg Tkwd TOPar TIdent < TOPar TIdent TCPar TIdent TPtrOp TIdent TCPar TIdent TPtrOp TIdent TOCro TIdent TCCro = TIdent TPtVirg TIdent TOPar & TIdent TPtrOp TIdent TComma TIdent TCPar TPtVirg TIdent = - TIdent TPtVirg TIdent TOPar & TIdent TPtrOp TIdent TCPar TPtVirg TIdent TOPar & TIdent TPtrOp TIdent TComma TIdent TCPar TPtVirg TIdent TOPar TIdent TComma TIdent TCPar TPtVirg TIdent TPtrOp TIdent TOCro TIdent TCCro = TIdent TPtVirg TIdent TOPar & TIdent TPtrOp TIdent TComma TIdent TCPar TPtVirg TIdent TOPar TIdent TCPar TPtVirg Tkwd TOPar TIdent TPtrOp TIdent TCPar TIdent TOPar TIdent TPtrOp TIdent TCPar TPtVirg
usb dwc3 enable when setconfiguration received as per databook bits should be set after receiving setconfiguration command	drivers usb dwc3 ep0 TIdent TIdent TPtVirg TIdent = TIdent TOPar TIdent TPtrOp TIdent TComma TIdent TCPar TPtVirg TIdent |= TOPar TIdent | TIdent TCPar TPtVirg TIdent TOPar TIdent TPtrOp TIdent TComma TIdent TComma TIdent TCPar TPtVirg drivers usb dwc3 gadget TIdent |= TOPar TIdent | TIdent TCPar TPtVirg
serial fix serial_cs windows for argosy rs-com current serial_cs driver has a problem when trying to detect whether a card has multiple ports serial_config calls pcmcia_loop_config which iterates over card cis configurations by calling serial_check_for_multi for each of them this function wants to check and select a configuration that has either one long window spanning multiple ports or two windows for two serial ports problem is that every pcmcia_loop_config iteration only updates the windows via pcmcia_do_loop_config in resource0 and resource1 when conf_auto_set_io flag is set on the device which is set only later in the code fix it by setting this flag earlier in addition to this when multi-port card is detected and it does not have an one long window multi_config_check_notpicky tries to locate two windows and assumes they are continuous without checking on an argosy rs-com this selects first configuration which unfortunately has two non-continuous windows the net effect is that the second serial port on the card does not work fix it by checking whether the windows are really continuous	drivers tty serial serial_cs TIdent TPtrOp TIdent |= TIdent | TIdent TPtVirg TIdent TPtrOp TIdent |= TIdent TPtVirg TIdent TPtrOp TIdent |= TIdent TPtVirg TIdent TPtrOp TIdent |= TIdent | TIdent TPtVirg Tkwd TOPar TBang TIdent TPtrOp TIdent TOCro TInt TCCro TPtrOp TIdent || TBang TIdent TPtrOp TIdent TOCro TInt TCCro TPtrOp TIdent || TIdent TPtrOp TIdent TOCro TInt TCCro TPtrOp TIdent + TInt != TIdent TPtrOp TIdent TOCro TInt TCCro TPtrOp TIdent TCPar Tkwd TOPar TBang TIdent TPtrOp TIdent TOCro TInt TCCro TPtrOp TIdent || TBang TIdent TPtrOp TIdent TOCro TInt TCCro TPtrOp TIdent TCPar TIdent TPtrOp TIdent |= TIdent TPtVirg
input wacom add abs_distance to bamboo pen reports tablet reports a distance of __number__ right at highest point possible to be in proximity and distance_max when touching tablet inverse the distance since user land has no way of knowing abs_distance is not distance from tablet	drivers input tablet wacom_wac Tkwd TOPar TIdent TOCro TInt TCCro <= TIdent TPtrOp TIdent TDot TIdent TCPar TIdent = TIdent TPtrOp TIdent TDot TIdent - TIdent TOCro TInt TCCro TPtVirg TIdent = TIdent TOCro TInt TCCro TPtVirg TIdent TOPar TIdent TComma TIdent TComma TInt TComma TIdent TPtrOp TIdent TComma TInt TComma TInt TCPar TPtVirg Tvis Tlifetime Ttcons TIdent TIdent = TOBrace TString TComma TIdent TComma TInt TComma TInt TComma TInt TComma TInt TComma TIdent TComma TIdent TComma TIdent TComma TCBrace TPtVirg Tvis Tlifetime Ttcons TIdent TIdent = TOBrace TString TComma TIdent TComma TInt TComma TInt TComma TInt TComma TInt TComma TIdent TComma TIdent TComma TIdent TComma TCBrace TPtVirg Tvis Tlifetime Ttcons TIdent TIdent = TOBrace TString TComma TIdent TComma TInt TComma TInt TComma TInt TComma TInt TComma TIdent TComma TIdent TComma TIdent TComma TCBrace TPtVirg Tvis Tlifetime Ttcons TIdent TIdent = TOBrace TString TComma TIdent TComma TInt TComma TInt TComma TInt TComma TInt TComma TIdent TComma TIdent TComma TIdent TComma TCBrace TPtVirg Tvis Tlifetime Ttcons TIdent TIdent = TOBrace TString TComma TIdent TComma TInt TComma TInt TComma TInt TComma TInt TComma TIdent TComma TIdent TComma TIdent TComma TCBrace TPtVirg Tvis Tlifetime Ttcons TIdent TIdent = TOBrace TString TComma TIdent TComma TInt TComma TInt TComma TInt TComma TInt TComma TIdent TComma TIdent TComma TIdent TComma TCBrace TPtVirg Tvis Tlifetime Ttcons TIdent TIdent = TOBrace TString TComma TIdent TComma TInt TComma TInt TComma TInt TComma TInt TComma TIdent TComma TIdent TComma TIdent TComma TCBrace TPtVirg Tvis Tlifetime Ttcons TIdent TIdent = TOBrace TString TComma TIdent TComma TInt TComma TInt TComma TInt TComma TInt TComma TIdent TComma TIdent TComma TIdent TComma TCBrace TPtVirg Tvis Tlifetime Ttcons TIdent TIdent = TOBrace TString TComma TIdent TComma TInt TComma TInt TComma TInt TComma TInt TComma TIdent TComma TIdent TComma TIdent TComma TCBrace TPtVirg Tvis Tlifetime Ttcons TIdent TIdent = TOBrace TString TComma TIdent TComma TInt TComma TInt TComma TInt TComma TInt TComma TIdent TComma TIdent TComma TIdent TComma TCBrace TPtVirg Tvis Tlifetime Ttcons TIdent TIdent = TOBrace TString TComma TIdent TComma TInt TComma TInt TComma TInt TComma TInt TComma TIdent TComma TIdent TComma TIdent TComma TCBrace TPtVirg Tvis Tlifetime Ttcons TIdent TIdent = TOBrace TString TComma TIdent TComma TInt TComma TInt TComma TInt TComma TInt TComma TIdent TComma TIdent TComma TIdent TComma TCBrace TPtVirg Tvis Tlifetime Ttcons TIdent TIdent = TOBrace TString TComma TIdent TComma TInt TComma TInt TComma TInt TComma TInt TComma TIdent TComma TIdent TComma TIdent TComma TCBrace TPtVirg Tvis Tlifetime Ttcons TIdent TIdent = TOBrace TString TComma TIdent TComma TInt TComma TInt TComma TInt TComma TInt TComma TIdent TComma TIdent TComma TIdent TComma TCBrace TPtVirg Tvis Tlifetime Ttcons TIdent TIdent = TOBrace TString TComma TIdent TComma TInt TComma TInt TComma TInt TComma TInt TComma TIdent TComma TIdent TComma TIdent TComma TCBrace TPtVirg Tvis Tlifetime Ttcons TIdent TIdent = TOBrace TString TComma TIdent TComma TInt TComma TInt TComma TInt TComma TInt TComma TIdent TComma TIdent TComma TIdent TComma TCBrace TPtVirg Tvis Tlifetime Ttcons TIdent TIdent = TOBrace TString TComma TIdent TComma TInt TComma TInt TComma TInt TComma TInt TComma TIdent TComma TIdent TComma TIdent TComma TCBrace TPtVirg Tvis Tlifetime Ttcons TIdent TIdent = TOBrace TString TComma TIdent TComma TInt TComma TInt TComma TInt TComma TInt TComma TIdent TComma TIdent TComma TIdent TComma TCBrace TPtVirg Tvis Tlifetime Ttcons TIdent TIdent = TOBrace TString TComma TIdent TComma TInt TComma TInt TComma TInt TComma TInt TComma TIdent TComma TIdent TComma TIdent TComma TCBrace TPtVirg Tvis Tlifetime Ttcons TIdent TIdent = TOBrace TString TComma TIdent TComma TInt TComma TInt TComma TInt TComma TInt TComma TIdent TComma TIdent TComma TIdent TComma TCBrace TPtVirg Tvis Ttcons TIdent TIdent = TOBrace TString TComma TIdent TComma TInt TComma TInt TComma TInt TComma TInt TComma TIdent TComma TIdent TComma TIdent TComma TCBrace TPtVirg Tvis Ttcons TIdent TIdent = TOBrace TString TComma TIdent TComma TInt TComma TInt TComma TInt TComma TInt TComma TIdent TComma TIdent TComma TIdent TComma TCBrace TPtVirg
xfs swap leaf buffer into path struct atomically during path shift the node directory lookup code uses a state structure that tracks the path of buffers used to search for the hash of a filename through the leaf blocks when the lookup encounters a block that ends with the requested hash but the entry has not yet been found it must shift over to the next block and continue looking for the entry duplicate hashes could continue over into the next block this shift mechanism involves walking back up and down the state structure replacing buffers at the appropriate btree levels as necessary when a buffer is replaced the old buffer is released and the new buffer read into the active slot in the path structure because the buffer is read directly into the path slot a buffer read failure can result in setting a null buffer pointer in an active slot this throws off the state cleanup code in xfs_dir2_node_lookup which expects to release a buffer from each active slot instead a bug occurs due to a null pointer dereference bug unable to handle kernel null pointer dereference at __number__ ip __address__ xfs rip __address__ __address__ xfs call trace __address__ xfs __address__ xfs __address__ xfs __address__ xfs __address__ __address__ __address__ this has been reproduced via a parallel fsstress and filesystem shutdown workload in a loop the shutdown triggers the read error in the aforementioned codepath and causes the bug in xfs_dir2_node_lookup update xfs_da3_path_shift to update the active path slot atomically with respect to the caller when a buffer is replaced this ensures that the caller always sees the old or new buffer in the slot and prevents the null pointer dereference	fs xfs libxfs xfs_da_btree Ttcons TIdent * TIdent TPtVirg TIdent = TIdent TOPar TIdent TPtrOp TIdent TComma TIdent TComma TIdent TComma - TInt TComma & TIdent TComma TIdent TPtrOp TIdent TCPar TPtVirg Tkwd TOPar TIdent TCPar Tkwd TIdent TPtVirg Tkwd TOPar TIdent TCPar TIdent TOPar TIdent TPtrOp TIdent TComma TIdent TPtrOp TIdent TCPar TPtVirg Tkwd TOPar TIdent TCPar TIdent TOPar TIdent TPtrOp TIdent TComma TIdent TPtrOp TIdent TCPar TPtVirg TIdent TPtrOp TIdent = TIdent TPtVirg TIdent = TIdent TOPar TIdent TPtrOp TIdent TComma TIdent TComma TIdent TComma - TInt TComma & TIdent TPtrOp TIdent TComma TIdent TPtrOp TIdent TCPar TPtVirg Tkwd TOPar TIdent TCPar Tkwd TIdent TPtVirg
fix null pointer dereference on cpu hotplug after disabling irqs in the current kernel percpu variable vector_irq is not always cleared when a cpu is offlined if the cpu that has the disabled irqs in vector_irq is hotplugged again __setup_vector_irq hits invalid irq vector and may crash this bug can be reproduced as following echo __number__ modprobe some_driver_using_interrupts uncleared echo __number__ kernel may crash to fix this problem this patch clears vector_irq in __fixup_irqs when the cpu is offlined this also reverts commit f6175f5bfb4c which partially fixes this bug by clearing vector in __clear_irq_vector but in environments with iommu irq remapper it could fail because doesnt contain offlined cpus with this patch the fix in __clear_irq_vector can be reverted because every vector_irq is already cleared in __fixup_irqs on offlined cpus link	arch x86 kernel apic io_apic TIdent TOPar TIdent TComma TIdent TPtrOp TIdent TComma TIdent TCPar TIdent TOPar TIdent TComma TIdent TPtrOp TIdent TCPar TIdent TOPar TIdent TComma TIdent TPtrOp TIdent TComma TIdent TCPar TIdent TOPar TIdent TComma TIdent TPtrOp TIdent TCPar arch x86 kernel irq TIdent TOPar TIdent TOCro TIdent TCCro TComma - TInt TCPar TPtVirg
x86 fix boot failures on older amd cpus people with old amd chips are getting hung boots because commit bcb80e53877c x86 microcode amd add microcode revision to moved the microcode detection too early into early_init_amd at that point we are early in the booth that the exception tables havent even been set up yet so the whole rdmsr_safemsr_amd64_patch_level doesnt actually work if the rdmsr does a gp fault due to non-existant msr register on older cpus we cant fix it up yet and the boot fails fix it by simply moving the code to a slightly later point in the boot init_amd instead of early_init_amd since the kernel itself doesnt even really care about the microcode patchlevel at this point or really ever its made available to user space in and updated if you do a microcode load	arch x86 kernel cpu amd TIdent TIdent TPtVirg TIdent TOPar TIdent TComma & TIdent TPtrOp TIdent TComma & TIdent TCPar TPtVirg TIdent TIdent TPtVirg TIdent TOPar TIdent TComma & TIdent TPtrOp TIdent TComma & TIdent TCPar TPtVirg
l2tp fix refcount leak in l2tp_ip sockets the l2tp_ip socket close handler does not update the module refcount correctly which prevents module unload after the first bind call on an l2tpv3 ip encapulation socket	net l2tp l2tp_ip TIdent TOPar TIdent TCPar TPtVirg TIdent TOPar & TIdent TPtrOp TIdent TCPar TPtVirg
fix panel fitter setting if need to enable the panel fitter the crtc timings have to be programmed according to the panels native fixed mode this isnt the case atm since after the encoder changes adjusted_mode to fixed mode the timing fields of adjusted_mode will stay at their original non-native values that the user passed in this results in a corrupted output one exception is when we have a second pass of computing encoder configs due to bandwidth limitation since then well set fields to the fixed mode values set in the first pass so in this case things will work out fix this by updating the fields when we set the fixed panel mode this regression has been introduced in commit date sun jul __number__ __number__ clean up crtc timings computation	drivers gpu drm i915 intel_panel TIdent TOPar TIdent TComma TInt TCPar TPtVirg
cfg80211 fix processing world regdomain when non modular this allows processing of the last regulatory request when we determine its still pending without this if a regulatory request failed to get processed by userspace we wouldnt be able to re-process it later an example situation that can lead to an unprocessed last_request is enabling cfg80211 to be built-in to the kernel not enabling cfg80211_internal_regdb and the crda binary not being available at the time the udev rule that kicks of crda triggers in such a situation we want to let some cfg80211 triggers eventually kick crda for us again without this if the first cycle attempt to kick off crda failed wed be stuck without the ability to change process any further regulatory domains cfg80211 will trigger re-processing of the regulatory queue whenever is called currently this happens when suspend resume disconnect a beacon hint gets triggered non dfs __number__ ghz ap found a regulatory request gets added to the queue we dont have any specific opportunistic late boot triggers to address a late mount of where crda resides though adding that should be done separately through another patch without an opportunistic fix then this fix relies at least one of the triggeres above to happen	net wireless reg TIdent TOPar TIdent TCPar TPtVirg TIdent TOPar TString TCPar TPtVirg
cxlflash fix to avoid corrupting adapter fops the fops owned by the adapter can be corrupted in certain scenarios opening a window where certain fops are temporarily nulled before being reset to their proper value this can potentially lead software to make incorrect decisions leaving the user with the inability to function as intended an example of this behavior can be observed when there are a number of users with a high rate of turn around attach to lun perform an detach from lun repeat every so often a user is given a valid context and adapter file descriptor but the file associated with the descriptor lacks the correct read permission bit fmode_can_read and thus the read system call bails before calling the valid read fop background the fops is stored in the adapter structure to provide the ability to lookup the adapter structure from within the fop handler cxl services use the files private_data and at present the cxl context does not have a private section in an effort to limit areas of the cxlflash driver with code specific the superpipe function a design choice was made to keep the details of the fops situated away from the legacy portions of the driver this drove the behavior that the adapter fops is set at the beginning of the disk attach ioctl handler when there are no users present the corruption that this fix remedies is due to the fact that the fops is initially defaulted to values found within a static structure when the fops is handed down to the cxl services later in the attach path certain services are patched the fops structure remains correct until the user count drops to __number__ and the fops is reset triggering the process to repeat again the user counts are tightly coupled with the creation and deletion of the user context if multiple users perform a disk attach at the same time when the user count is currently __number__ some users can be in the middle of obtaining a file descriptor and have not yet reached the context creation code that in addition to creating the context increments the user count subsequent users coming in to perform the attach see that the user count is still __number__ and reinitialize the fops temporarily removing the patched fops the users that are in the middle obtaining their file descriptor may then receive an invalid descriptor the fix simply removes the user count altogether and moves the fops initialization to probe time such that it is only performed one time for the life of the adapter in the future if the cxl services adopt a private member for their context that could be used to store the adapter structure reference and cxlflash could revert to a model that does not require an embedded fops	drivers scsi cxlflash common Tvis Tlifetime Ttcons TIdent TIdent TPtVirg TIdent TIdent TPtVirg drivers scsi cxlflash main TIdent TPtrOp TIdent = TIdent TPtVirg drivers scsi cxlflash superpipe TIdent TOPar & TIdent TPtrOp TIdent TCPar TPtVirg TIdent TOPar & TIdent TPtrOp TIdent TCPar TPtVirg Tlifetime Ttcons TIdent TIdent = TOBrace TDot TIdent = TIdent TComma TDot TIdent = TIdent TComma TDot TIdent = TIdent TComma TCBrace TPtVirg Tvis Tlifetime Ttcons TIdent TIdent = TOBrace TDot TIdent = TIdent TComma TDot TIdent = TIdent TComma TDot TIdent = TIdent TComma TCBrace TPtVirg Tkwd TOPar TIdent TOPar & TIdent TPtrOp TIdent TCPar == TInt TCPar TIdent TPtrOp TIdent = TIdent TPtVirg
acpi pci pm fix device pm regression related to commit acpi fix d3hot v d3cold confusion introduced a bug in __acpi_bus_set_power and changed the behavior of acpi_pci_set_power_state in such a way that it generally doesnt work as expected if pci_d3hot is passed to it as the second argument first off if acpi_state_d3 equal to acpi_state_d3_cold is passed to __acpi_bus_set_power and the explicit_set flag is set for the d3cold state the function will try to execute aml method called _ps4 which doesnt exist fix this by adding a check to ensure that the name of the aml method to execute for transitions to acpi_state_d3_cold is correct in __acpi_bus_set_power also make sure that the explicit_set flag for acpi_state_d3_cold will be set if _ps3 is present and modify acpi_power_transition to avoid accessing power resources for acpi_state_d3_cold because they dont exist second if pci_d3hot is passed to acpi_pci_set_power_state as the target state the function will request a transition to acpi_state_d3_hot instead of acpi_state_d3 however acpi_state_d3_hot is now only marked as supported if the _pr3 aml method is defined for the given device which is rare this causes problems to happen on systems where devices were successfully put into acpi d3 by pci_set_power_statepci_d3hot which doesnt work now in particular some unused graphics adapters are not turned off as a result to fix this issue restore the old behavior of acpi_pci_set_power_state which is to request a transition to acpi_state_d3 equal to acpi_state_d3_cold if either pci_d3hot or pci_d3cold is passed to it as the argument this approach is not ideal because generally power should not be removed from devices if pci_d3hot is the target power state but since this behavior is relied on we have no choice but to restore it at the moment and spend more time on designing a better solution in the future references	drivers acpi bus Tkwd TOPar TIdent == TIdent TCPar TIdent TOCro TInt TCCro = TChar TPtVirg drivers acpi power Ttype TIdent = TInt TPtVirg Ttype TIdent TPtVirg Tkwd TOPar TIdent < TIdent TCPar TIdent = TIdent TOPar & TIdent TPtrOp TIdent TDot TIdent TOCro TIdent TCCro TDot TIdent TCPar TPtVirg Tkwd TOPar TBang TIdent && TIdent TPtrOp TIdent TDot TIdent < TIdent TCPar TIdent = TIdent TOPar & TIdent TPtrOp TIdent TDot TIdent TOCro TIdent TCCro TDot TIdent TCPar TPtVirg Tkwd TOPar TBang TIdent TCPar drivers acpi scan Tkwd TOPar TIdent TPtrOp TIdent TDot TIdent TOCro TIdent TCCro TDot TIdent TDot TIdent TCPar TIdent TPtrOp TIdent TDot TIdent TOCro TIdent TCCro TDot TIdent TDot TIdent = TInt TPtVirg drivers pci pci-acpi Tvis Tlifetime TIdent TIdent TOCro TCCro = TOBrace TOCro TIdent TCCro = TIdent TComma TOCro TIdent TCCro = TIdent TComma TOCro TIdent TCCro = TIdent TComma TOCro TIdent TCCro = TIdent TComma TOCro TIdent TCCro = TIdent TComma TCBrace TPtVirg Tvis Tlifetime TIdent TIdent TOCro TCCro = TOBrace TOCro TIdent TCCro = TIdent TComma TOCro TIdent TCCro = TIdent TComma TOCro TIdent TCCro = TIdent TComma TOCro TIdent TCCro = TIdent TComma TOCro TIdent TCCro = TIdent TComma TCBrace TPtVirg
prevent leak of scratch register on resume from suspend cards typically have scratch registers one of these is reserved for unfortunately the reservation is done in function r100_cp_init which is called by all drivers except r600 and this function is also invoked on resume from suspend after several resumes no scratch registers are free and graphics acceleration is disabled dmesg then reports either radeon cp failed to get scratch reg radeon cp isnt working-22 radeon __number__ failed initializing cp or radeon failed to get scratch reg radeon failed testing ib on gfx ring ib ring test failed the chain of calls on boot for all except r600 is radeon_init rxxx_init rxxx_startup r100_cp_init the chain of calls on resume for all except r600 is rxxx_resume rxxx_startup r100_cp_init r600 correctly allocates rptr_save_reg in r600_init ie once only not in resume however moving the code into the init functions for all drivers means touching __number__ drivers so instead this patch just adds a test in r100_cp_init to avoid reallocating on resume as the rdev structure is allocated via kzalloc in radeon_driver_load_kms and zero is not a valid registerid zero safely implies not-yet-allocated this issue appears to have been introduced in	drivers gpu drm radeon r100 Tkwd TOPar TBang TIdent TPtrOp TIdent && TIdent TOPar TIdent TComma TIdent TCPar TCPar Tkwd TOPar TIdent TOPar TIdent TComma TIdent TCPar TCPar
serial sh-sci fix possible race cases on scscr register accesses in the previous commit console write function serial_console_write is changed to disable sci interrupts while printing console strings this introduces possible race cases in the serial startup shutdown functions on smp systems this patch fixes the sh-sci in the same way as commit tty serial imx console write routing is unsafe on smp from xinyu chen did there could be several consumers of the console the kernel printk the init process using to call printk to show log shell which opens and writes with sys_write the shell goes into the normal uart open and write system calls while the other two go into the console operations the open call invokes serial startup function sci_startup which will write to the scscr register to enable or disable sci interrupts without any locking this will conflict with the console serial function add spinlock protections in sci_startup and sci_shutdown properly	drivers tty serial sh-sci Tsign Ttype TIdent TPtVirg TIdent TOPar & TIdent TPtrOp TIdent TComma TIdent TCPar TPtVirg TIdent TOPar & TIdent TPtrOp TIdent TComma TIdent TCPar TPtVirg Tsign Ttype TIdent TPtVirg TIdent TOPar & TIdent TPtrOp TIdent TComma TIdent TCPar TPtVirg TIdent TOPar & TIdent TPtrOp TIdent TComma TIdent TCPar TPtVirg
revert bluetooth always wait for a connection on rfcomm open this reverts commit this is the second of a revert together with revert bluetooth remove rfcomm_carrier_raised and revert bluetooth move rfcomm_get_device before rfcomm_dev_activate before commit cad348a17e170451ea8688b532a6ca3e98c63b60 bluetooth implement and methods tty_port_block_til_ready was open-coded in rfcomm_tty_install as part of the rfcomm tty open unfortunately it did not implement non-blocking open nor clocal open but rather always blocked for carrier this is not the expected or typical behavior for ttys and prevents several common terminal programming idioms from working opening in non-blocking mode to initialize desired termios settings then re-opening for connection commit cad348a17e170451ea8688b532a6ca3e98c63b60 bluetooth implement and methods added the necessary tty_port methods to use the default tty_port_open however this triggered two important user-space regressions the first regression involves the complicated mechanism for reparenting the rfcomm tty device to the acl link device which represents an open link to a specific bluetooth host this regression causes modemmanager to conclude the rfcomm tty device does not front a modem so it makes no attempt to initialize an attached modem this regression is caused by the lack of a device_move if the dlc is already open and not specifically related to the open-coded block_til_ready a more appropriate solution is submitted in bluetooth fix unsafe rfcomm device parenting and bluetooth fix rfcomm parent device for reused dlc the second regression involves rfcomm bind and wvdial a ppp dialer rfcomm bind creates a device node for a wvdial opens that device in non-blocking mode because it expects the connection to have already been established in addition subsequent writes to the rfcomm tty device fail because the link is not yet connected rfcomm connection begins with the actual tty open however restoring the original behavior in the patch which this reverts was undesirable firstly the original reporter notes that a trivial userspace workaround already exists rfcomm connect which creates the device node and establishes the expected connection secondly the failed writes occur because the rfcomm tty driver does not buffer writes to an unconnected device this contrasts with the dozen of other tty drivers in fact all of them that do just that the submitted patch bluetooth dont fail rfcomm tty writes corrects this thirdly it was a long-standing bug to block on non-blocking open which is re-fixed by revert	net bluetooth rfcomm tty TIdent TIdent TPtVirg TIdent TOPar TIdent TCPar TPtVirg Ttype TIdent TPtVirg TIdent = TIdent TOPar TIdent TPtrOp TIdent TComma & TIdent TPtrOp TIdent TComma & TIdent TPtrOp TIdent TComma TIdent TPtrOp TIdent TCPar TPtVirg Tkwd TOPar TIdent TCPar Tkwd TIdent TPtVirg Tkwd TOPar TInt TCPar TIdent TOPar & TIdent TPtrOp TIdent TComma & TIdent TComma TIdent TCPar TPtVirg Tkwd TIdent TOPar TIdent TPtrOp TIdent TComma & TIdent TPtrOp TIdent TComma & TIdent TPtrOp TIdent TComma TIdent TPtrOp TIdent TCPar TPtVirg Tkwd TOPar TIdent TPtrOp TIdent TPtrOp TIdent == TIdent TCPar TIdent = - TIdent TPtrOp TIdent TPtVirg Tkwd TPtVirg Tkwd TOPar TIdent TPtrOp TIdent TPtrOp TIdent == TIdent TCPar Tkwd TPtVirg Tkwd TOPar TIdent TOPar TIdent TCPar TCPar TIdent = - TIdent TPtVirg Tkwd TPtVirg TIdent TOPar TIdent TCPar TPtVirg TIdent TOPar TCPar TPtVirg TIdent TOPar TIdent TCPar TPtVirg TIdent TOPar & TIdent TPtrOp TIdent TComma & TIdent TCPar TPtVirg Tkwd TOPar TBang TIdent TCPar TIdent TOPar TIdent TPtrOp TIdent TComma TIdent TOPar TIdent TCPar TComma TIdent TCPar TPtVirg Tkwd TIdent TPtVirg Tvis Tlifetime Ttcons TIdent TIdent = TOBrace TDot TIdent = TIdent TComma TDot TIdent = TIdent TComma TDot TIdent = TIdent TComma TDot TIdent = TIdent TComma TCBrace TPtVirg TIdent TOPar & TIdent TPtrOp TIdent TCPar TPtVirg Tkwd TOPar TIdent TPtrOp TIdent == TIdent TCPar TIdent TOPar TIdent TPtrOp TIdent TComma TIdent TOPar TIdent TCPar TComma TIdent TCPar TPtVirg TIdent TOPar & TIdent TPtrOp TIdent TCPar TPtVirg TIdent TOPar & TIdent TPtrOp TIdent TDot TIdent TCPar TPtVirg Tkwd TOPar TIdent TPtrOp TIdent == TIdent TCPar Tkwd TOPar TIdent TPtrOp TIdent == TIdent TCPar TIdent TPtrOp TIdent TDot TIdent = TIdent | TIdent | TIdent | TIdent TPtVirg TIdent TPtrOp TIdent TDot TIdent = TIdent | TIdent | TIdent | TIdent | TIdent TPtVirg
ubifs fix power cut emulation for mtdram the power cut emulation did not work correctly because we corrupted more than one max unit in the buffer and then wrote the entire buffer this lead to recovery errors because ubifs complained about corrupted free space and this was easily reproducible on mtdram because max write size is very small there __number__ bytes and we could easily have a buffer corrupt __number__ bytes there and then write the entire buffer the fix is to corrupt max write size bytes at most and write only up to the last corrupted max write size chunk not the entire buffer	fs ubifs debug Tvis Ttype TIdent TOPar Tlifetime Ttcons TIdent * TIdent TComma Tlifetime Ttype * TIdent TComma Tsign Ttype TIdent TCPar Tvis Ttype TIdent TOPar Tlifetime Ttype * TIdent TComma Tsign Ttype TIdent TCPar TIdent = TIdent TOPar TIdent TComma TIdent TOPar TIdent TComma TIdent TPtrOp TIdent TCPar TCPar TPtVirg Tkwd TOPar TIdent TOPar TInt TComma TInt TCPar TCPar TIdent = TIdent TOPar TCPar % TOPar TIdent - TIdent + TInt TCPar TPtVirg TIdent = TIdent TPtVirg TIdent TOPar TString TComma TIdent TComma TIdent - TInt TComma TIdent TWhy TString TDotDot TString TCPar TPtVirg Tkwd TOPar TIdent < TIdent TCPar TIdent TOPar TString TComma TIdent TComma TIdent - TInt TComma TIdent TWhy TString TDotDot TString TCPar TPtVirg Tkwd TIdent TPtVirg TIdent = TIdent TOPar TIdent TComma TIdent TComma TIdent TCPar TPtVirg TIdent TOPar TString TComma TIdent TComma TIdent TComma TIdent TCPar TPtVirg TIdent TOPar TIdent TComma TIdent TCPar TPtVirg
rtlwifi rtl8188ee missing curly braces in handle_branch1 from the indenting it seems like the read_next_pair was supposed to be inside the while loop	drivers net wireless rtlwifi rtl8188ee phy Tkwd TOPar TIdent != TInt && TIdent != TInt && TIdent != TInt && TIdent < TIdent - TInt TCPar Tkwd TOPar TIdent != TInt && TIdent != TInt && TIdent != TInt && TIdent < TIdent - TInt TCPar
hid usbhid prevent unwanted events to be sent when re-opening the device when events occurs while no one is listening to the node __number__ and usb_kill_urb called some events are still stacked somewhere in the usb kernel or stack when the node gets reopened these events are drained and this results in spurious touch or mouse button clicks the problem was spotted with touchscreens in fdo bug __number__ but it actually occurs with any mouse using hid-generic or touchscreen a way to reproduce it is to call xinput disable __number__ sleep __number__ xinput enable __number__ with __number__ being the device id for the during the sleep produce some touch events or click events when xinput enable is called at least one click is generated this patch tries to fix this by draining the queue for __number__ msec and during this time frame not forwarding these old events to the hid layer hans completed the explanation devices like mice basically any hid device will have a fifo on the device side when we stop submitting urbs to get hid reports from it that fifo will fill up and when we resume we will get whatever is there in that fifo __number__	drivers hid usbhid hid-core Tkwd TOPar TBang TIdent TOPar TIdent TComma & TIdent TPtrOp TIdent TCPar TCPar TIdent TOPar TIdent TPtrOp TIdent TComma TIdent TComma TIdent TPtrOp TIdent TComma TIdent TPtrOp TIdent TComma TInt TCPar TPtVirg TIdent TOPar TIdent TPtrOp TIdent TComma TIdent TComma TIdent TPtrOp TIdent TComma TIdent TPtrOp TIdent TComma TInt TCPar TPtVirg Tkwd TOPar TIdent TOPar TIdent TCPar TCPar TIdent TOPar TIdent TComma & TIdent TPtrOp TIdent TCPar TPtVirg TIdent TOPar TIdent TComma & TIdent TPtrOp TIdent TCPar TPtVirg Tkwd TOPar TIdent TOPar TIdent TCPar TCPar TIdent TOPar TIdent TComma & TIdent TPtrOp TIdent TCPar TPtVirg TIdent TOPar TIdent TComma & TIdent TPtrOp TIdent TCPar TPtVirg TIdent TOPar TIdent TComma & TIdent TPtrOp TIdent TCPar TPtVirg TIdent TOPar TInt TCPar TPtVirg TIdent TOPar TIdent TComma & TIdent TPtrOp TIdent TCPar TPtVirg drivers hid usbhid usbhid TDefine TIdent TInt
fix an endian bug in atom table parsing	drivers gpu drm radeon radeon_atombios TIdent TPtrOp TIdent = TOPar TIdent TCPar TOPar TOPar TIdent TOPar TIdent TPtrOp TIdent TCPar - TIdent TOPar TIdent TComma TIdent TCPar TCPar / TIdent TCPar TPtVirg TIdent TPtrOp TIdent = TOPar TIdent TCPar TOPar TOPar TIdent TPtrOp TIdent - TIdent TOPar TIdent TComma TIdent TCPar TCPar / TIdent TCPar TPtVirg
iser-target fix reject cm event use-after-free oops this patch fixes a bug in iser-target code where the reject cm event handler code currently performs a isert_put_conn for the final put while iscsi_np process context is still blocked in isert_get_login_rx once isert_get_login_rx is awoking due to login timeout iscsi_np process context will attempt to invoke iscsi_target_login_sess_out to cleanup iscsi_conn as expected and calls isert_wait_conn isert_free_conn which triggers the use-after-free oops to address this bug move the kref_get_unless_zero call from isert_connected_handler into isert_connect_request immediately preceeding isert_rdma_accept to ensure the cm handler cleanup paths and isert_free_conn are always operating with two refs	drivers infiniband ulp isert ib_isert Tkwd TOPar TBang TIdent TOPar & TIdent TPtrOp TIdent TCPar TCPar TIdent TOPar TString TComma TIdent TCPar TPtVirg Tkwd TIdent TPtVirg Tkwd TOPar TBang TIdent TOPar & TIdent TPtrOp TIdent TCPar TCPar TIdent TOPar TString TComma TIdent TCPar TPtVirg Tkwd TPtVirg
fix fairness issue on migration pavan reported that in the presence of very light tasks or cgroups the placement of migrated tasks can cause severe fairness issues the problem is that enqueue_entity places the task before it updates time thereby it can place the task far in the past remember that light tasks will shoot virtual time forward at a high speed so in relation to the pre-existing light task we can land far in the past this is done because update_curr needs the current task and we might be placing the current task the obvious solution is to differentiate between the current and any other task placing the current before we update time and placing any other task after such that tasks end up at the current moment in time and not in the past this commit re-introduces the previously reverted commit fix fairness issue on migration which is now safe to do after weve also fixed another underlying bug first in prepare to fix fairness problems on migration and cleaned up other details in the migration code kill	kernel sched fair TIdent TIdent = TBang TOPar TIdent & TIdent TCPar || TOPar TIdent & TIdent TCPar TPtVirg TIdent TIdent = TIdent TPtrOp TIdent == TIdent TPtVirg Tkwd TOPar TIdent && TIdent TCPar Tkwd TOPar TBang TOPar TIdent & TIdent TCPar || TOPar TIdent & TIdent TCPar TCPar TIdent TOPar TIdent TCPar TPtVirg Tkwd TOPar TIdent && TBang TIdent TCPar TIdent TPtrOp TIdent += TIdent TPtrOp TIdent TPtVirg TIdent TOPar TIdent TCPar TPtVirg Tkwd TOPar TBang TIdent TCPar Tkwd TOPar TIdent != TIdent TPtrOp TIdent TCPar
cgroup fix cgroup hierarchy umount race cgroup make clearing on cgroup removal optional allowed a css to linger after the associated cgroup is removed as a css holds a reference on the cgroups dentry it means that cgroup dentries may linger for a while destroying a superblock which has dentries with positive refcnts is a critical bug and triggers bug in vfs code as each cgroup dentry holds an s_active reference any lingering cgroup has both its dentry and the superblock pinned and thus preventing premature release of superblock unfortunately after theres a small window while releasing a cgroup which is directly under the root of the hierarchy when a cgroup directory is released vfs layer first deletes the corresponding dentry and then invokes dput on the parent which may recurse further so when a cgroup directly below root cgroup is released the cgroup is first destroyed which releases the s_active it was holding and then the dentry for the root cgroup is dput this creates a window where the root dentrys refcnt isnt zero but superblocks s_active is if umount happens before or during this window vfs will see the root dentry with non-zero refcnt and trigger bug before this problem didnt exist because the last dentry reference was guaranteed to be put synchronously from rmdir2 invocation which holds s_active around the whole process fix it by holding an extra reference across dput from css release which is the dput path added by and the only one which doesnt hold an extra s_active ref across the final cgroup dput lkml-reference huawei.com	kernel cgroup Ttcons TIdent * TIdent = TIdent TPtrOp TIdent TPtrOp TIdent TPtVirg Ttcons TIdent * TIdent = TIdent TPtrOp TIdent TPtVirg TIdent TOPar & TIdent TPtrOp TIdent TCPar TPtVirg TIdent TOPar TIdent TCPar TPtVirg TIdent TOPar TIdent TCPar TPtVirg TIdent TOPar TIdent TPtrOp TIdent TPtrOp TIdent TCPar TPtVirg
btrfs fix crash of compressed writes the crash1 is found by with compress its not reproduced everytime but it does panic the bug is quite interesting its actually introduced by a recent commit btrfs actually limit the size of delalloc range btrfs implements delay allocation so during writeback we __number__ get a page a and lock it __number__ search the state tree for delalloc bytes and lock all pages within the range __number__ process the delalloc range including find disk space and create ordered extent and so on __number__ submit the page a it runs well in normal cases but if were in a racy case eg buffered compressed writes and aio-dio writes sometimes we may fail to lock all pages in the delalloc range in which case we need to fall back to search the state tree again with a smaller range limitmax_bytes page_cache_size offset the mentioned commit has a side effect that is in the fallback case we can find delalloc bytes before the index of the page we already have locked so were in the case of delalloc_end and return with found __number__ this ends with not locking delalloc pages but making still process them and the crash happens this fixes it by just thinking that we find nothing and returning to caller as the caller knows how to deal with it properly __number__ cut here kernel bug at cpu __number__ pid __number__ comm btrfs-delalloc- tainted g o rip __address__ __address__ __float__ stack __float__ __address__ __address__ __address__ __address__ __float__ __number__ __number__ __number__ __number__ __float__ __address__ __address__ __address__ __number__ __float__ call trace __float__ __address__ btrfs __float__ __address__ btrfs __float__ __address__ __float__ __address__ btrfs __float__ __address__ btrfs __float__ __address__ btrfs __float__ __address__ __float__ __address__ __float__ __address__ __float__ __address__ __float__ code ff __number__ c0 __number__ c0 b6 c0 __number__ c3 __number__ __number__ __number__ __number__ __number__ __number__ e5 __number__ __number__ __number__ __number__ __number__ fb e8 de __number__ __number__ __number__ __number__ c4 __number__ __number__ a8 __number__ __number__ __number__ __number__ e4 __number__ __number__ __number__ __number__ __number__ __number__ __number__ __number__ __number__ f6 __number__ __number__ __number__ __number__ __number__ __float__ rip __address__ __float__ rsp __address__ __float__ end trace	fs btrfs extent_io Tkwd TInt TPtVirg Tkwd TIdent TPtVirg
udf dont corrupt unalloc spacetable when writing it for a udf filesystem configured with an unallocated space table a filesystem operation that triggers an update to the table results in on-disk corruption that prevents remounting udf_read_tagged tag version __number__ block __number__ for example __number__ create a filesystem mkudffs __number__ mount it mount __number__ create a file echo no corruption please __number__ umount umount __number__ attempt remount mount this appears to be a longstanding bug caused by zero-initialization of the unallocated space entry block buffer and only partial repopulation of required fields before writing to disk commit udf fix unalloc space handling in udf_update_inode addressed one such field but several others are required	fs udf inode TIdent = Tkwd TOPar Ttcons TIdent TCPar TPtVirg TIdent TPtrOp TIdent TDot TIdent = TIdent TOPar TIdent TPtrOp TIdent TDot TIdent TCPar TPtVirg TIdent = Tkwd TOPar Ttcons TIdent TCPar + TIdent TPtrOp TIdent - Tkwd TOPar Ttcons TIdent TCPar TPtVirg TIdent TPtrOp TIdent TDot TIdent = TIdent TOPar TIdent TCPar TPtVirg TIdent TPtrOp TIdent TDot TIdent = TIdent TOPar TIdent TOPar TInt TComma TOPar Ttype * TCPar TIdent + Tkwd TOPar Ttcons TIdent TCPar TComma TIdent TCPar TCPar TPtVirg TIdent TPtrOp TIdent TDot TIdent = TIdent TOPar & TIdent TPtrOp TIdent TCPar TPtVirg Tkwd TIdent TPtVirg Tkwd TIdent TPtVirg TIdent TDotDot Tkwd TOPar TIdent TPtrOp TIdent TCPar TOBrace TIdent TPtrOp TIdent TDot TIdent = TIdent TOPar TInt TCPar TPtVirg TIdent TPtrOp TIdent TDot TIdent = TIdent TOPar TInt TCPar TPtVirg TIdent TPtrOp TIdent TDot TIdent = TIdent TOPar TInt TCPar TPtVirg TCBrace Tkwd TOBrace TIdent TPtrOp TIdent TDot TIdent = TIdent TOPar TInt TCPar TPtVirg TIdent TPtrOp TIdent TDot TIdent = TIdent TOPar TInt TCPar TPtVirg TCBrace Tkwd TOPar TIdent TPtrOp TIdent TCPar TIdent TPtrOp TIdent TDot TIdent = TIdent TPtVirg Tkwd TOPar TIdent TOPar TIdent TPtrOp TIdent TCPar TCPar Tkwd TOPar TIdent TOPar TIdent TPtrOp TIdent TCPar TCPar TIdent TDotDot TIdent TOPar TIdent TCPar TPtVirg
serial samsung fix serial console break this patch fixes problems with serial console break when function s3c64xx_serial_startup was started while serial console has been working it caused lose of characters written to tx fifo this effect was particularly observable with systemd which closes serial port every time when its not currently needed hence function s3c64xx_serial_startup is called quite often there to fix this problem we avoid resetting tx fifo if port is used as serial console example of broken console log __float__ expecting device __number__ ok reached target paths __float__ s ok reached target swap __float__ systemd1 reached target swap __float__ systemd1 starting root slice __float__ ok created slice root slice __float__ systemd1 create ok created slice user and session slice __float__ sys ok listening on compatibility named pipe __float__ s ok listening on delayed shutdown socket __float__ sy ok listening on journal socket __float__ ok listening on udev kernel socket __float__ s ok listening on udev control socket __float__ s ok listening on journal socket __float__ systemd1 listeni ok created slice system slice __float__ mounting temporary __float__ starting prepare device __float__ sy starting generate environment from __float__ system starting create static device nodes in __float__ mounting debug file __float__ mounting configuration file __float__ starting apply kernel __float__ starting setup virtual __float__ starting udev coldplug all __float__ starting journal ok started journal service __float__ s ok reached target slices starting remount root and kernel file ok mounted configuration file system	drivers tty serial samsung TIdent |= TIdent | TIdent TPtVirg Tkwd TOPar TBang TIdent TOPar TIdent TCPar TCPar TIdent |= TIdent TPtVirg TIdent |= TIdent | TIdent | TIdent TPtVirg
arm64 kvm vgic-v3 prevent the guest from messing with icc_sre_el1 both our gic emulations are strict in the sense that we either emulate a gicv2 or a gicv3 and not a gicv3 with gicv2 legacy support but when running on a gicv3 host we still allow the guest to tinker with the icc_sre_el1 register during its time slice it can switch sre off observe that it is off and yet on the next world switch find the sre bit to be set again not very nice an obvious solution is to always trap accesses to icc_sre_el1 by clearing and to let the handler return the programmed value on a read or ignore the write that way the guest can always observe that our gicv3 is only	arch arm64 kvm hyp vgic-v3-sr TIdent TOPar TIdent TOPar TIdent TCPar & TTilde TIdent TComma TIdent TCPar TPtVirg Tkwd TOPar TBang TIdent TPtrOp TIdent TCPar TIdent TOPar TIdent TOPar TIdent TCPar & TTilde TIdent TComma TIdent TCPar TPtVirg
crush allow crush rules to set retries counts to __number__ these two fields are misnomers they are counts reflects commit f17caba8ae0cad7b6f8f35e53e5f73b444696835	net ceph crush mapper Tkwd TOPar TIdent TPtrOp TIdent >= TInt TCPar Tkwd TOPar TIdent TPtrOp TIdent > TInt TCPar Tkwd TOPar TIdent TPtrOp TIdent >= TInt TCPar Tkwd TOPar TIdent TPtrOp TIdent > TInt TCPar
mtd nand disable subpage writes for drivers without nand_write_subpage_hwecc causes a crash if the driver did not register or fix this by disabling subpage writes if or is not provided by the driver this behavior was introduced in commit mtd nand subpage write support for hardware based ecc schemes this fixes a crash with fsl_elbc_nand and maybe others unable to handle kernel paging request for instruction fetch faulting instruction address __number__ oops kernel access of bad area sig __number__ smp p1020 rdb modules linked in ath9k ath9k_common pppoe ppp_async option iptable_nat ath9k_hw ath usb_wwan pppox ppp_generic nf_nat_ipv4 nf_conntrack_ipv4 mac80211 ipt_masquerade cfg80211 xt_time xt_tcpudp xt_state xt_quota xt_policy xt_pkttype xt_owner xt_nat xt_multiport xt_mh cpu __number__ pid __number__ comm ubiformat not tainted task ti __number__ __number__ nip __number__ lr ctr __number__ regs trap __number__ not tainted msr __number__ cr __number__ xer __number__ gpr00 __number__ __number__ __number__ gpr08 __number__ __number__ __number__ __number__ gpr16 __number__ __number__ __number__ __number__ __number__ __number__ gpr24 __number__ __number__ __number__ __number__ nip __number__ null lr call trace unreliable exception c01 at lr instruction dump xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx end trace kernel panic not syncing fatal exception brian editorial note weve applied a previous fix for the driver in question fsl_elbc_nand long ago commit f034d87def51 mtd elbc nand fix subpage write support but this still makes sense and it could solve issues on some other unforseen driver	drivers mtd nand nand_base Tkwd TOPar TBang TIdent TPtrOp TIdent && TIdent TPtrOp TIdent && TIdent TPtrOp TIdent TCPar Tkwd TOPar TBang TIdent TPtrOp TIdent TCPar
alsa usb-audio fix max packet size calculation for usb audio rounding must take place before multiplication with the frame size since each packet contains a whole number of frames we must also properly consider the data interval as a larger data interval will result in larger packets which depending on the sampling frequency can result in packet sizes that are less than integral multiples of the packet size for a lower data interval detailed explanation and rationale the code before this commit had the following expression on line __number__ to calculate the maximum isochronous packet size maxsize __address__ frame_bits __number__ __number__ here is the maximum assumed sample frequency calculated from the nominal sample frequency plus it is ultimately derived from which is in the units of frames per packet from get_usb_full_speed_rate or usb_high_speed_rate as applicable in format the expression essentially adds the equivalent of the largest number less than one to the sample rate in order to get a rate whose integer part is rounded up from the fractional value the multiplication with frame_bits __number__ yields the number of bytes in a packet and the __number__ then converts it from back to an integer taking into consideration the bdatainterval field of the endpoint descriptor which describes how often isochronous packets are transmitted relative to the microframe rate or for usb high speed and full speed respectively for this discussion we will initially assume a bdatainterval of __number__ so the second line of the expression just converts the value to an integer in order to illustrate the problem we will set frame_bits __number__ which corresponds to a frame size of __number__ bytes the problem here is twofold first the rounding operation consists of the addition of __address__ and subsequent conversion to integer but as the expression stands the conversion to integer is done after multiplication with the frame size rather than before this results in the resulting maxsize becoming too large lets take an example we have a sample rate of __number__ khz so our is __number__ see usb_high_speed_rate add line __number__ and we get __number__ the calculated maxsize is then __number__ __address__ __number__ __number__ __number__ however if we do the number of bytes calculation in a less obscure way its more apparent what the true corresponding packet size is we get ceil96000 __float__ __number__ __number__ __number__ where __float__ is the from line __number__ and the __number__ is the number of isochronous packets per second on a high speed usb connection __number__ us microframe interval this is fixed by performing the complete rounding operation prior to multiplication with the frame rate the second problem is that when considering the this must be done before rounding in order to take the advantage of the fact that if the number of bytes per packet is not an integer the resulting rounded-up integer is not necessarily a factor of two when the data interval is increased by the same factor for instance assuming a freqency of __number__ khz the resulting bytes-per-packet value for usb high speed is __number__ khz __number__ __float__ or in format with a data interval of __number__ __number__ this means that __number__ frames per packet are needed whereas with a data interval of __number__ we need __float__ __number__ frames needed rephrasing the maxsize expression to maxsize __address__ __number__ frame_bits __number__ for the above __number__ khz example we instead get __number__ __address__ __number__ __number__ __number__ which is the correct value we can also do the calculation with a non-integer sample rate which is when rounding comes into effect say we have __float__ khz resulting and resulting __float__ rounded down original maxsize __address__ __number__ __number__ __number__ rounded down true maxsize ceil44100 __float__ __number__ __number__ __number__ __number__ __number__ new maxsize __address__ __number__ __number__ __number__ __number__ __number__ this is also corroborated by the wmaxpacketsize check on line __number__ assume that wmaxpacketsize __number__ with then having the same value as __number__ __number__ we get maxsize __number__ is then recalculated to __number__ __number__ __number__ __number__ putting that rate into the original maxsize calculation yields a maxsize of __number__ __address__ __number__ __number__ __number__ with decimals __float__ clearly we should get back the __number__ here which we would with the new expression __number__ __address__ __number__ __number__ __number__ the error has not been a problem because it only results in maxsize being a bit too big which just wastes a couple of bytes either as a result of the first maxsize calculation or because the resulting calculation will hit the wmaxpacketsize value before the packet is too big resulting in fixing the size to wmaxpacketsize even though the packet is actually not too long tested with an edirol ua-5 both at __float__ khz and __number__ khz	sound usb endpoint TIdent = TOPar TOPar TOPar TIdent TPtrOp TIdent << TIdent TPtrOp TIdent TCPar + TInt TCPar >> TInt TCPar * TOPar TIdent >> TInt TCPar TPtVirg TIdent = TOPar TOPar TIdent TPtrOp TIdent + TInt TCPar * TOPar TIdent >> TInt TCPar TCPar >> TOPar TInt - TIdent TPtrOp TIdent TCPar TPtVirg
md faulty use disk_stack_limits in block do not artificially constrain max_sectors for stacking drivers max_sectors defaults to uint_max md faulty wasnt using disk_stack_limits so inherited this large value as well this triggered a bug in xfs when stressed over md_faulty when a very large bio_alloc failed that was on an older kernel and i cant reproduce exactly the same thing upstream but i think the fix is appropriate in any case thanks to mike snitzer for pointing out the problem	drivers md faulty TIdent TOPar TIdent TComma TIdent TCPar TIdent TOPar TIdent TComma TIdent TCPar TIdent TOPar TIdent TPtrOp TIdent TComma TIdent TPtrOp TIdent TComma TIdent TPtrOp TIdent << TInt TCPar TPtVirg
f2fs merge meta writes as many possible this patch tries to merge ios as many as possible when background flusher conducts flushing the dirty meta pages before dev write_syncmp meta sector __number__ size __number__ f2fs_submit_write_bio dev write_syncmp meta sector __number__ size __number__ f2fs_submit_write_bio dev write_syncmp meta sector __number__ size __number__ f2fs_submit_write_bio dev write_syncmp meta sector __number__ size __number__ f2fs_submit_write_bio dev write_syncmp meta sector __number__ size __number__ f2fs_submit_write_bio dev write_syncmp meta sector __number__ size __number__ f2fs_submit_write_bio dev write_syncmp meta sector __number__ size __number__ f2fs_submit_write_bio dev write_syncmp meta sector __number__ size __number__ f2fs_submit_write_bio dev write_syncmp meta sector __number__ size __number__ f2fs_submit_write_bio dev write_syncmp meta sector __number__ size __number__ f2fs_submit_write_bio dev write_syncmp meta sector __number__ size __number__ f2fs_submit_write_bio dev write_syncmp meta sector __number__ size __number__ f2fs_submit_write_bio dev write_syncmp meta sector __number__ size __number__ f2fs_submit_write_bio dev write_syncmp meta sector __number__ size __number__ f2fs_submit_write_bio dev write_syncmp meta sector __number__ size __number__ f2fs_submit_write_bio dev write_syncmp meta sector __number__ size __number__ after f2fs_submit_write_bio dev write_syncmp meta sector __number__ size __number__ f2fs_submit_write_bio dev write_syncmp meta sector __number__ size __number__ f2fs_submit_write_bio dev write_syncmp meta sector __number__ size __number__ f2fs_submit_write_bio dev write_syncmp meta sector __number__ size __number__ f2fs_submit_write_bio dev write_syncmp meta sector __number__ size __number__ f2fs_submit_write_bio dev write_syncmp meta sector __number__ size __number__ f2fs_submit_write_bio dev write_syncmp meta sector __number__ size __number__ f2fs_submit_write_bio dev write_syncmp meta sector __number__ size __number__ f2fs_submit_write_bio dev write_syncmp meta sector __number__ size __number__ f2fs_submit_write_bio dev write_syncmp meta sector __number__ size __number__ f2fs_submit_write_bio dev write_syncmp meta sector __number__ size __number__	fs f2fs checkpoint TIdent TIdent = TInt TComma TIdent = TIdent TComma TIdent = TIdent TPtVirg TIdent TIdent = TInt TComma TIdent = TIdent TPtVirg Tkwd TOPar TIdent == TIdent TCPar TIdent = TIdent TPtrOp TIdent - TInt TPtVirg Tkwd TOPar TIdent != TIdent && TIdent TPtrOp TIdent != TIdent + TInt TCPar TIdent TOPar & TIdent TCPar TPtVirg Tkwd TIdent TPtVirg TIdent = TIdent TPtrOp TIdent TPtVirg TIdent TDotDot Tkwd TOPar TIdent TCPar TIdent TOPar TIdent TComma TIdent TComma TIdent TCPar TPtVirg
reset csb read pointer in ring init a previous commit enabled execlists by default commit enable execlists by default where supported this allowed routine testing of execlists which exposed a regression when resuming from suspend the cause was tracked down the to recent changes to the ring init sequence commit only init engines once during a cycle the hardware context status buffer write pointer is reset however since the recent changes to the init sequence the software csb read pointer is no longer reset this means that context status events are not handled correctly and new contexts are not written to the elsp resulting in an apparent gpu hang pending further changes to the ring init code just move the initialization into gen8_init_common_ring to fix this regression v2 moved init into gen8_init_common_ring rather than context_enable after feedback from daniel vetter updated commit msg to reflect this and also cite commits related to the regression fixed bz link to correct bug bugzilla	drivers gpu drm i915 intel_lrc TIdent TPtrOp TIdent = TInt TPtVirg TIdent TPtrOp TIdent = TInt TPtVirg
add px quirk for asus k53tk seems to have problems turning the dgpu bug	drivers gpu drm radeon radeon_device Tvis Ttcons TIdent TIdent TOCro TCCro = TOBrace TOBrace TIdent TComma TInt TComma TInt TComma TInt TComma TIdent TComma TCBrace TComma TOBrace TIdent TComma TInt TComma TInt TComma TInt TComma TIdent TComma TCBrace TComma TOBrace TIdent TComma TInt TComma TInt TComma TInt TComma TIdent TComma TCBrace TComma TOBrace TIdent TComma TInt TComma TIdent TComma TInt TComma TIdent TComma TCBrace TComma TOBrace TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TCBrace TComma TCBrace TPtVirg
xfs collapse range is delalloc challenged fsx has been detecting data corruption after to collapse range calls the key observation is that the offset of the last extent in the file was not being shifted and hence when the file size was adjusted it was truncating away data because the extents handled been correctly shifted tracing indicated that before the collapse the extent list looked like ino state idx __number__ offset __number__ block __number__ count __number__ flag __number__ ino state idx __number__ offset __number__ block __number__ count __number__ flag __number__ ino state idx __number__ offset __number__ block __number__ count __number__ flag __number__ and after the shift of __number__ blocks ino state idx __number__ offset __number__ block __number__ count __number__ flag __number__ ino state idx __number__ offset __number__ block __number__ count __number__ flag __number__ ino state idx __number__ offset __number__ block __number__ count __number__ flag __number__ note that the last extent did not change offset after the changing of the file size ino state idx __number__ offset __number__ block __number__ count __number__ flag __number__ ino state idx __number__ offset __number__ block __number__ count __number__ flag __number__ ino state idx __number__ offset __number__ block __number__ count __number__ flag __number__ you can see that the last extent had its length truncated indicating that weve lost data the reason for this is that the xfs_bmap_shift_extents loop uses xfs_ifork_nextents to determine how many extents are in the inode this unfortunately doesnt take into account delayed allocation extents its a count of physically allocated extents and hence when the file being collapsed has a delalloc extent like this one does prior to the range being collapsed ino state idx __number__ offset __number__ block __number__ count __number__ flag __number__ it gets the count wrong and terminates the shift loop early fix it by using the in-memory extent array size that includes delayed allocation extents to determine the number of extents on the inode	fs xfs xfs_bmap Ttype TIdent TPtVirg TIdent = TIdent TPtrOp TIdent / Tkwd TOPar TIdent TCPar TPtVirg Tkwd TOPar TIdent ++ < TIdent && * TIdent < TIdent TCPar Tkwd TOPar TIdent ++ < TIdent && * TIdent < TIdent TOPar TIdent TComma TIdent TCPar TCPar TIdent = TIdent TPtrOp TIdent / Tkwd TOPar TIdent TCPar TPtVirg Tkwd TOPar * TIdent == TIdent TCPar Tkwd TOPar * TIdent == TIdent TOPar TIdent TComma TIdent TCPar TCPar
dmaengine at_xdmac fix missing spin_unlock lock taken when entering the function but unlock missing before it returns	drivers dma at_xdmac TIdent TOPar & TIdent TPtrOp TIdent TCPar TPtVirg
kvm s390 fix hang vcpu regression commit kvm s390 optimize round trip time in request handling introduced a regression this regression was seen with cpu hotplug in the guest and switching between __number__ or __number__ cpus this will the ibs control via synced request whenever we make a synced request we first set the bit and then block the vcpu the handler on the other hand unblocks itself processes by clearing them and unblocks itself once again now if the requester sleeps between setting of and blocking the handler will clear the bit and try to unblock itself although no bit is set when the requester wakes up it blocks the vcpu and we have a blocked vcpu without requests solution is to always unset the block bit	arch s390 kvm kvm-s390 Tkwd TOPar TBang TIdent TPtrOp TIdent TCPar Tkwd TInt TPtVirg Tkwd TOPar TBang TIdent TPtrOp TIdent TCPar Tkwd TInt TPtVirg
random fix handing of arch_get_random_long in get_random_bytes if there is an architecture-specific random number generator we use it to acquire randomness one long at a time we should put these random words into consecutive words in the result buffer not just overwrite the first word again and again link	drivers char random TIdent TOPar TIdent TComma & TIdent TComma TIdent TCPar TPtVirg TIdent TOPar TIdent TComma & TIdent TComma TIdent TCPar TPtVirg
ext4 fix ext4 mismerge back in january duplicate caused afaics by mismerge in	fs ext4 ioctl TIdent TOPar TIdent TPtrOp TIdent TDot TIdent TCPar TPtVirg
btrfs gfp_nofs does not gfp_highmem masking highmem out of nofs does not make sense	fs btrfs delayed-inode TIdent = TIdent TOPar TIdent TCPar TPtVirg TIdent = TIdent TOPar TIdent & TTilde TIdent TCPar TPtVirg fs btrfs disk-io TIdent = TIdent TOPar TIdent TCPar TPtVirg TIdent = TIdent TOPar TIdent & TTilde TIdent TCPar TPtVirg fs btrfs extent_io TIdent = TIdent TOPar TIdent TCPar TPtVirg TIdent = TIdent TOPar TIdent & TTilde TIdent TCPar TPtVirg TIdent = TIdent TOPar TIdent TCPar TPtVirg TIdent = TIdent TOPar TIdent & TTilde TIdent TCPar TPtVirg
alsa hda correct aamix output paths the output paths including aamix should be parsed only for the first output the surround paths including aamix must be wrong since it would mix all streams all channels would be mixed into a single and multiplexed again	sound pci hda hda_generic Tkwd TOPar TBang TIdent && TBang TIdent && TIdent TPtrOp TIdent TCPar Tkwd TOPar TBang TIdent && TIdent > TInt && TIdent TPtrOp TIdent TCPar Tkwd TOPar TBang TIdent && TBang TIdent && TIdent TPtrOp TIdent TCPar Tkwd TOPar TBang TIdent && TIdent > TInt && TIdent TPtrOp TIdent TCPar
alsa fix gpio1 setup for acer aspire __number__ co add gpio1 setup explicitly for acer aspire co this could be set by alc_auto_init_amp but its safer to set it more explicitly in the fixup table	sound pci hda patch_realtek Tvis Tlifetime Ttcons TIdent TIdent TOCro TCCro = TOBrace TOCro TIdent TCCro = TOBrace TDot TIdent = TIdent TComma TDot TIdent TDot TIdent = TOPar Tlifetime Ttcons TIdent TOCro TCCro TCPar TOBrace TOBrace TInt TComma TInt TComma TCBrace TComma TOBrace TInt TComma TInt TComma TCBrace TComma TOBrace TInt TComma TInt TComma TCBrace TComma TOBrace TCBrace TComma TCBrace TComma TCBrace TComma TOCro TIdent TCCro = TOBrace TDot TIdent = TIdent TComma TDot TIdent TDot TIdent = TOPar Tlifetime Ttcons TIdent TOCro TCCro TCPar TOBrace TOBrace TInt TComma TInt TComma TCBrace TComma TOBrace TInt TComma TInt TComma TCBrace TComma TOBrace TCBrace TComma TCBrace TComma TCBrace TComma TOCro TIdent TCCro = TOBrace TDot TIdent = TIdent TComma TDot TIdent TDot TIdent = TOPar Tlifetime Ttcons TIdent TOCro TCCro TCPar TOBrace TOBrace TInt TComma TIdent TComma TIdent TComma TCBrace TComma TOBrace TCBrace TComma TCBrace TComma TCBrace TComma TOCro TIdent TCCro = TOBrace TDot TIdent = TIdent TComma TDot TIdent TDot TIdent = TIdent TComma TCBrace TComma TOCro TIdent TCCro = TOBrace TDot TIdent = TIdent TComma TDot TIdent TDot TIdent = TOPar Tlifetime Ttcons TIdent TOCro TCCro TCPar TOBrace TOBrace TInt TComma TInt TComma TCBrace TComma TOBrace TCBrace TComma TCBrace TComma TCBrace TComma TOCro TIdent TCCro = TOBrace TDot TIdent = TIdent TComma TDot TIdent TDot TIdent = TOPar Tlifetime Ttcons TIdent TOCro TCCro TCPar TOBrace TOBrace TInt TComma TInt TComma TCBrace TComma TOBrace TCBrace TComma TCBrace TComma TCBrace TComma TOCro TIdent TCCro = TOBrace TDot TIdent = TIdent TComma TDot TIdent TDot TIdent = TOPar Tlifetime Ttcons TIdent TOCro TCCro TCPar TOBrace TOBrace TInt TComma TInt TComma TCBrace TComma TOBrace TCBrace TComma TCBrace TComma TCBrace TComma TOCro TIdent TCCro = TOBrace TDot TIdent = TIdent TComma TDot TIdent TDot TIdent = TOPar Tlifetime Ttcons TIdent TOCro TCCro TCPar TOBrace TOBrace TInt TComma TIdent TComma TInt TComma TCBrace TComma TOBrace TInt TComma TIdent TComma TInt TComma TCBrace TComma TOBrace TCBrace TComma TCBrace TComma TCBrace TComma TOCro TIdent TCCro = TOBrace TDot TIdent = TIdent TComma TDot TIdent TDot TIdent = TOPar Tlifetime Ttcons TIdent TOCro TCCro TCPar TOBrace TOBrace TInt TComma TIdent TComma TInt TComma TCBrace TComma TOBrace TInt TComma TIdent TComma TInt TComma TCBrace TComma TOBrace TCBrace TComma TCBrace TComma TCBrace TComma TOCro TIdent TCCro = TOBrace TDot TIdent = TIdent TComma TDot TIdent TDot TIdent = TOPar Tlifetime Ttcons TIdent TOCro TCCro TCPar TOBrace TOBrace TInt TComma TIdent TComma TInt TComma TCBrace TComma TOBrace TInt TComma TIdent TComma TInt TComma TCBrace TComma TOBrace TCBrace TComma TCBrace TComma TCBrace TComma TOCro TIdent TCCro = TOBrace TDot TIdent = TIdent TComma TDot TIdent TDot TIdent = TOPar Tlifetime Ttcons TIdent TOCro TCCro TCPar TOBrace TOBrace TInt TComma TIdent TComma TInt TComma TCBrace TComma TOBrace TInt TComma TIdent TComma TInt TComma TCBrace TComma TOBrace TCBrace TComma TCBrace TComma TCBrace TComma TOCro TIdent TCCro = TOBrace TDot TIdent = TIdent TComma TDot TIdent TDot TIdent = TIdent TComma TCBrace TComma TOCro TIdent TCCro = TOBrace TDot TIdent = TIdent TComma TDot TIdent TDot TIdent = TIdent TComma TCBrace TComma TOCro TIdent TCCro = TOBrace TDot TIdent = TIdent TComma TDot TIdent TDot TIdent = TIdent TComma TCBrace TComma TOCro TIdent TCCro = TOBrace TDot TIdent = TIdent TComma TDot TIdent TDot TIdent = TIdent TComma TDot TIdent = TIdent TComma TDot TIdent = TIdent TComma TCBrace TComma TOCro TIdent TCCro = TOBrace TDot TIdent = TIdent TComma TDot TIdent TDot TIdent = TIdent TComma TCBrace TComma TOCro TIdent TCCro = TOBrace TDot TIdent = TIdent TComma TDot TIdent TDot TIdent = TOPar Tlifetime Ttcons TIdent TOCro TCCro TCPar TOBrace TOBrace TInt TComma TInt TComma TCBrace TComma TOBrace TInt TComma TInt TComma TCBrace TComma TOBrace TCBrace TComma TCBrace TComma TDot TIdent = TIdent TComma TDot TIdent = TIdent TComma TCBrace TComma TOCro TIdent TCCro = TOBrace TDot TIdent = TIdent TComma TDot TIdent TDot TIdent = TOPar Tlifetime Ttcons TIdent TOCro TCCro TCPar TOBrace TOBrace TInt TComma TInt TComma TCBrace TComma TOBrace TInt TComma TInt TComma TCBrace TComma TOBrace TCBrace TComma TCBrace TComma TDot TIdent = TIdent TComma TDot TIdent = TIdent TComma TCBrace TComma TOCro TIdent TCCro = TOBrace TDot TIdent = TIdent TComma TDot TIdent TDot TIdent = TOPar Tlifetime Ttcons TIdent TOCro TCCro TCPar TOBrace TOBrace TInt TComma TIdent TComma TInt TComma TCBrace TComma TOBrace TInt TComma TIdent TComma TInt TComma TCBrace TComma TOBrace TInt TComma TIdent TComma TInt TComma TCBrace TComma TOBrace TInt TComma TIdent TComma TInt TComma TCBrace TComma TOBrace TInt TComma TIdent TComma TInt TComma TCBrace TComma TOBrace TInt TComma TIdent TComma TInt TComma TCBrace TComma TOBrace TInt TComma TIdent TComma TInt TComma TCBrace TComma TOBrace TInt TComma TIdent TComma TInt TComma TCBrace TComma TOBrace TCBrace TComma TCBrace TComma TDot TIdent = TIdent TComma TDot TIdent = TIdent TComma TCBrace TComma TOCro TIdent TCCro = TOBrace TDot TIdent = TIdent TComma TDot TIdent TDot TIdent = TIdent TComma TCBrace TComma TOCro TIdent TCCro = TOBrace TDot TIdent = TIdent TComma TDot TIdent TDot TIdent = TIdent TComma TCBrace TComma TOCro TIdent TCCro = TOBrace TDot TIdent = TIdent TComma TDot TIdent TDot TIdent = TIdent TComma TDot TIdent = TIdent TComma TDot TIdent = TIdent TComma TCBrace TComma TOCro TIdent TCCro = TOBrace TDot TIdent = TIdent TComma TDot TIdent TDot TIdent = TIdent TComma TDot TIdent = TIdent TComma TDot TIdent = TIdent TComma TCBrace TComma TCBrace TPtVirg Tvis Tlifetime Ttcons TIdent TIdent TOCro TCCro = TOBrace TOCro TIdent TCCro = TOBrace TDot TIdent = TIdent TComma TDot TIdent TDot TIdent = TOPar Tlifetime Ttcons TIdent TOCro TCCro TCPar TOBrace TOBrace TInt TComma TInt TComma TCBrace TComma TOBrace TInt TComma TInt TComma TCBrace TComma TOBrace TInt TComma TInt TComma TCBrace TComma TOBrace TCBrace TComma TCBrace TComma TCBrace TComma TOCro TIdent TCCro = TOBrace TDot TIdent = TIdent TComma TDot TIdent TDot TIdent = TOPar Tlifetime Ttcons TIdent TOCro TCCro TCPar TOBrace TOBrace TInt TComma TInt TComma TCBrace TComma TOBrace TInt TComma TInt TComma TCBrace TComma TOBrace TCBrace TComma TCBrace TComma TCBrace TComma TOCro TIdent TCCro = TOBrace TDot TIdent = TIdent TComma TDot TIdent TDot TIdent = TOPar Tlifetime Ttcons TIdent TOCro TCCro TCPar TOBrace TOBrace TInt TComma TIdent TComma TIdent TComma TCBrace TComma TOBrace TCBrace TComma TCBrace TComma TCBrace TComma TOCro TIdent TCCro = TOBrace TDot TIdent = TIdent TComma TDot TIdent TDot TIdent = TIdent TComma TCBrace TComma TOCro TIdent TCCro = TOBrace TDot TIdent = TIdent TComma TDot TIdent TDot TIdent = TOPar Tlifetime Ttcons TIdent TOCro TCCro TCPar TOBrace TOBrace TInt TComma TInt TComma TCBrace TComma TOBrace TCBrace TComma TCBrace TComma TCBrace TComma TOCro TIdent TCCro = TOBrace TDot TIdent = TIdent TComma TDot TIdent TDot TIdent = TOPar Tlifetime Ttcons TIdent TOCro TCCro TCPar TOBrace TOBrace TInt TComma TInt TComma TCBrace TComma TOBrace TCBrace TComma TCBrace TComma TCBrace TComma TOCro TIdent TCCro = TOBrace TDot TIdent = TIdent TComma TDot TIdent TDot TIdent = TOPar Tlifetime Ttcons TIdent TOCro TCCro TCPar TOBrace TOBrace TInt TComma TInt TComma TCBrace TComma TOBrace TCBrace TComma TCBrace TComma TCBrace TComma TOCro TIdent TCCro = TOBrace TDot TIdent = TIdent TComma TDot TIdent TDot TIdent = TOPar Tlifetime Ttcons TIdent TOCro TCCro TCPar TOBrace TOBrace TInt TComma TIdent TComma TInt TComma TCBrace TComma TOBrace TInt TComma TIdent TComma TInt TComma TCBrace TComma TOBrace TCBrace TComma TCBrace TComma TCBrace TComma TOCro TIdent TCCro = TOBrace TDot TIdent = TIdent TComma TDot TIdent TDot TIdent = TOPar Tlifetime Ttcons TIdent TOCro TCCro TCPar TOBrace TOBrace TInt TComma TIdent TComma TInt TComma TCBrace TComma TOBrace TInt TComma TIdent TComma TInt TComma TCBrace TComma TOBrace TCBrace TComma TCBrace TComma TCBrace TComma TOCro TIdent TCCro = TOBrace TDot TIdent = TIdent TComma TDot TIdent TDot TIdent = TOPar Tlifetime Ttcons TIdent TOCro TCCro TCPar TOBrace TOBrace TInt TComma TIdent TComma TInt TComma TCBrace TComma TOBrace TInt TComma TIdent TComma TInt TComma TCBrace TComma TOBrace TCBrace TComma TCBrace TComma TCBrace TComma TOCro TIdent TCCro = TOBrace TDot TIdent = TIdent TComma TDot TIdent TDot TIdent = TOPar Tlifetime Ttcons TIdent TOCro TCCro TCPar TOBrace TOBrace TInt TComma TIdent TComma TInt TComma TCBrace TComma TOBrace TInt TComma TIdent TComma TInt TComma TCBrace TComma TOBrace TCBrace TComma TCBrace TComma TCBrace TComma TOCro TIdent TCCro = TOBrace TDot TIdent = TIdent TComma TDot TIdent TDot TIdent = TIdent TComma TCBrace TComma TOCro TIdent TCCro = TOBrace TDot TIdent = TIdent TComma TDot TIdent TDot TIdent = TIdent TComma TCBrace TComma TOCro TIdent TCCro = TOBrace TDot TIdent = TIdent TComma TDot TIdent TDot TIdent = TIdent TComma TCBrace TComma TOCro TIdent TCCro = TOBrace TDot TIdent = TIdent TComma TDot TIdent TDot TIdent = TIdent TComma TDot TIdent = TIdent TComma TDot TIdent = TIdent TComma TCBrace TComma TOCro TIdent TCCro = TOBrace TDot TIdent = TIdent TComma TDot TIdent TDot TIdent = TIdent TComma TCBrace TComma TOCro TIdent TCCro = TOBrace TDot TIdent = TIdent TComma TDot TIdent TDot TIdent = TOPar Tlifetime Ttcons TIdent TOCro TCCro TCPar TOBrace TOBrace TInt TComma TInt TComma TCBrace TComma TOBrace TInt TComma TInt TComma TCBrace TComma TOBrace TCBrace TComma TCBrace TComma TCBrace TComma TOCro TIdent TCCro = TOBrace TDot TIdent = TIdent TComma TDot TIdent TDot TIdent = TOPar Tlifetime Ttcons TIdent TOCro TCCro TCPar TOBrace TOBrace TInt TComma TInt TComma TCBrace TComma TOBrace TInt TComma TInt TComma TCBrace TComma TOBrace TCBrace TComma TCBrace TComma TDot TIdent = TIdent TComma TDot TIdent = TIdent TComma TCBrace TComma TOCro TIdent TCCro = TOBrace TDot TIdent = TIdent TComma TDot TIdent TDot TIdent = TOPar Tlifetime Ttcons TIdent TOCro TCCro TCPar TOBrace TOBrace TInt TComma TIdent TComma TInt TComma TCBrace TComma TOBrace TInt TComma TIdent TComma TInt TComma TCBrace TComma TOBrace TInt TComma TIdent TComma TInt TComma TCBrace TComma TOBrace TInt TComma TIdent TComma TInt TComma TCBrace TComma TOBrace TInt TComma TIdent TComma TInt TComma TCBrace TComma TOBrace TInt TComma TIdent TComma TInt TComma TCBrace TComma TOBrace TInt TComma TIdent TComma TInt TComma TCBrace TComma TOBrace TInt TComma TIdent TComma TInt TComma TCBrace TComma TOBrace TCBrace TComma TCBrace TComma TCBrace TComma TOCro TIdent TCCro = TOBrace TDot TIdent = TIdent TComma TDot TIdent TDot TIdent = TIdent TComma TCBrace TComma TOCro TIdent TCCro = TOBrace TDot TIdent = TIdent TComma TDot TIdent TDot TIdent = TIdent TComma TCBrace TComma TOCro TIdent TCCro = TOBrace TDot TIdent = TIdent TComma TDot TIdent TDot TIdent = TIdent TComma TDot TIdent = TIdent TComma TDot TIdent = TIdent TComma TCBrace TComma TOCro TIdent TCCro = TOBrace TDot TIdent = TIdent TComma TDot TIdent TDot TIdent = TIdent TComma TDot TIdent = TIdent TComma TDot TIdent = TIdent TComma TCBrace TComma TCBrace TPtVirg
fix off-mode bug clear debounce settings on this change was originally titled fix off-mode bug clear debounce clock enable mask on the title has been updated slightly to reflect what should be the final fix when a gpio is freed or shutdown we need to ensure that any debounce settings are cleared and if the gpio is the only gpio in the bank that is currently using debounce then disable the debounce clock as well to save power currently the debounce settings are not cleared on a gpio free or shutdown and so during a context restore on subsequent off-mode transition the previous debounce values are restored from the shadow copies leading to mismatch state between driver state and hardware state this was discovered when board code was doing gpio_request_one gpio_set_debounce gpio_free which was leaving the gpio debounce settings in a confused state if that gpio bank is subsequently used with off-mode enabled bogus state would be restored leaving gpio debounce enabled which then prevented the core powerdomain from transitioning to fix this introduce a new function called _clear_gpio_debounce to clear any debounce settings when the gpio is freed or shutdown if this gpio is the last debounce-enabled gpio in the bank the debounce will also be cut please note that we cannot use _gpio_dbck_disable to disable the debounce clock because this has been specifically created for the gpio suspend path and is intended to shutdown the debounce clock while debounce is enabled special thanks to kevin hilman for root causing the bug this fix is a collaborative effort with inputs from kevin hilman grazvydas ignotas and santosh shilimkar testing this has been unit tested on an omap3430 beagle board by requesting a gpio enabling debounce and then freeing the gpio and checking the register contents the saved register context and the debounce clock state kevin hilman tested on board which configures gpio debounce for the ads7846 touchscreen in its board file using the above sequence and so was failing off-mode tests in dynamic idle verified that off-mode tests are passing with this patch v5 changes corrected author	drivers gpio gpio-omap Tvis Ttype TIdent TOPar Ttcons TIdent * TIdent TComma Tsign TIdent TCPar TIdent TIdent = TIdent TOPar TIdent TComma TIdent TCPar TPtVirg Tkwd TOPar TBang TIdent TPtrOp TIdent TCPar Tkwd TPtVirg Tkwd TOPar TBang TOPar TIdent TPtrOp TIdent & TIdent TCPar TCPar Tkwd TPtVirg TIdent TPtrOp TIdent &= TTilde TIdent TPtVirg TIdent TPtrOp TIdent TDot TIdent &= TTilde TIdent TPtVirg TIdent TOPar TIdent TPtrOp TIdent TDot TIdent TComma TIdent TPtrOp TIdent + TIdent TPtrOp TIdent TPtrOp TIdent TCPar TPtVirg Tkwd TOPar TBang TIdent TPtrOp TIdent TCPar TIdent TPtrOp TIdent TDot TIdent = TInt TPtVirg TIdent TOPar TIdent TPtrOp TIdent TDot TIdent TComma TIdent TPtrOp TIdent + TIdent TPtrOp TIdent TPtrOp TIdent TCPar TPtVirg TIdent TOPar TIdent TPtrOp TIdent TCPar TPtVirg TIdent TPtrOp TIdent = TIdent TPtVirg TIdent TOPar TIdent TComma TIdent TCPar TPtVirg
netfilter nf_conntrack fix tcp_in_window for fast open currently the conntrack checks if the ending sequence of a packet falls within the observed receive window however it does so even if it has not observe any packet from the remote yet and uses an uninitialized receive window td_maxwin if a connection uses fast open to send a syn-data packet which is dropped afterward in the network the subsequent syns retransmits will all fail this check and be discarded leading to a connection timeout this is because the syn retransmit does not contain data payload so end initial sequence number isn __number__ isn syn_data_len __number__ the fix is to only apply this check after td_maxwin is initialized	net netfilter nf_conntrack_proto_tcp TIdent TIdent TComma TIdent TPtVirg TIdent TIdent TPtVirg TIdent = TBang TIdent TPtrOp TIdent || TIdent TOPar TIdent TComma TIdent TPtrOp TIdent - TIdent TPtrOp TIdent - TInt TCPar TPtVirg TIdent TOPar TString TComma TIdent TOPar TIdent TComma TIdent TPtrOp TIdent + TInt TCPar TComma TOPar TIdent TWhy TInt TDotDot TInt TCPar TComma TIdent TOPar TIdent TComma TIdent TPtrOp TIdent + TInt TCPar TComma TIdent TOPar TIdent TComma TIdent TPtrOp TIdent - TIdent TOPar TIdent TCPar - TInt TCPar TCPar TPtVirg TIdent TOPar TString TComma TIdent TOPar TIdent TComma TIdent TPtrOp TIdent + TInt TCPar TComma TIdent TOPar TIdent TComma TIdent TPtrOp TIdent - TIdent TPtrOp TIdent - TInt TCPar TComma TIdent TOPar TIdent TComma TIdent TPtrOp TIdent + TInt TCPar TComma TIdent TOPar TIdent TComma TIdent TPtrOp TIdent - TIdent TOPar TIdent TCPar - TInt TCPar TCPar TPtVirg Tkwd TOPar TIdent TOPar TIdent TComma TIdent TPtrOp TIdent + TInt TCPar && TIdent && TIdent TOPar TIdent TComma TIdent TPtrOp TIdent + TInt TCPar && TIdent TOPar TIdent TComma TIdent TPtrOp TIdent - TIdent TOPar TIdent TCPar - TInt TCPar TCPar Tkwd TOPar TIdent TOPar TIdent TComma TIdent TPtrOp TIdent + TInt TCPar && TIdent TOPar TIdent TComma TIdent TPtrOp TIdent - TIdent TPtrOp TIdent - TInt TCPar && TIdent TOPar TIdent TComma TIdent TPtrOp TIdent + TInt TCPar && TIdent TOPar TIdent TComma TIdent TPtrOp TIdent - TIdent TOPar TIdent TCPar - TInt TCPar TCPar TIdent TOPar TIdent TComma TIdent TComma TInt TComma TIdent TComma TIdent TComma TIdent TComma TIdent TComma TString TComma TIdent TOPar TIdent TComma TIdent TPtrOp TIdent + TInt TCPar TWhy TIdent TWhy TIdent TOPar TIdent TComma TIdent TPtrOp TIdent + TInt TCPar TWhy TIdent TOPar TIdent TComma TIdent TPtrOp TIdent - TIdent TOPar TIdent TCPar - TInt TCPar TWhy TString TDotDot TString TDotDot TString TDotDot TString TDotDot TString TCPar TPtVirg TIdent TOPar TIdent TComma TIdent TComma TInt TComma TIdent TComma TIdent TComma TIdent TComma TIdent TComma TString TComma TIdent TOPar TIdent TComma TIdent TPtrOp TIdent + TInt TCPar TWhy TIdent TOPar TIdent TComma TIdent TPtrOp TIdent - TIdent TPtrOp TIdent - TInt TCPar TWhy TIdent TOPar TIdent TComma TIdent TPtrOp TIdent + TInt TCPar TWhy TIdent TOPar TIdent TComma TIdent TPtrOp TIdent - TIdent TOPar TIdent TCPar - TInt TCPar TWhy TString TDotDot TString TDotDot TString TDotDot TString TDotDot TString TCPar TPtVirg
dmaengine at_xdmac fix memory leak in interleaved mode in interleaved mode when numf __number__ we have only one descriptor for the transfer but this descriptor has to be added to the descs_list if not when doing remove_xfer the descriptor wont be put back in the free_descs_list	drivers dma at_xdmac TIdent TOPar TIdent TOPar TIdent TCPar TComma TString TComma TIdent TComma TIdent TComma TIdent TCPar TPtVirg TIdent TOPar & TIdent TPtrOp TIdent TComma & TIdent TPtrOp TIdent TCPar TPtVirg
ksm dont fail stable tree lookups if walking over stale stable_nodes the stable_nodes can become stale at any time if the underlying pages gets freed the stable_node gets collected and removed from the stable rbtree if that is detected during the rbtree lookups dont fail the lookup if running into stale stable_nodes just restart the lookup after collecting the stale stable_nodes otherwise the cpu spent in the preparation stage is wasted and the lookup must be repeated at the next loop potentially failing a second time in a second stale stable_node if we dont prune aggressively we delay the merging of the unstable node candidates and at the same time we delay the freeing of the stale stable_nodes keeping stale stable_nodes around wastes memory and it cant provide any benefit	mm ksm Tkwd TOPar TBang TIdent TCPar Tkwd TIdent TPtVirg Tkwd TOPar TBang TIdent TCPar Tkwd TIdent TPtVirg Ttcons TIdent * TIdent TPtVirg Ttcons TIdent * TIdent = TIdent TPtVirg TIdent TDotDot TIdent = TIdent TPtVirg TIdent = TIdent TPtVirg Tkwd TOPar TBang TIdent TCPar Tkwd TIdent TPtVirg Tkwd TOPar TBang TIdent TCPar Tkwd TIdent TPtVirg
input synaptics fix min-max quirk value for commit input synaptics add quirk for thinkpad had a typo in ymax this changes the value to the one reported by touchpad-edge-detector and mentioned in the commit	drivers input mouse synaptics Tvis Tlifetime Ttcons TIdent TIdent TOCro TCCro = TOBrace TOBrace TOPar Tlifetime Ttype * Tlifetime TOCro TCCro TCPar TOBrace TString TComma TIdent TComma TCBrace TComma TOBrace TIdent TComma TIdent TComma TCBrace TComma TInt TComma TInt TComma TInt TComma TInt TComma TCBrace TComma TOBrace TOPar Tlifetime Ttype * Tlifetime TOCro TCCro TCPar TOBrace TString TComma TIdent TComma TCBrace TComma TOBrace TIdent TComma TIdent TComma TCBrace TComma TInt TComma TInt TComma TInt TComma TInt TComma TCBrace TComma TOBrace TOPar Tlifetime Ttype * Tlifetime TOCro TCCro TCPar TOBrace TString TComma TString TComma TString TComma TString TComma TString TComma TString TComma TIdent TComma TCBrace TComma TOBrace TIdent TComma TInt TComma TCBrace TComma TInt TComma TInt TComma TInt TComma TInt TComma TCBrace TComma TOBrace TOPar Tlifetime Ttype * Tlifetime TOCro TCCro TCPar TOBrace TString TComma TIdent TComma TCBrace TComma TOBrace TIdent TComma TIdent TComma TCBrace TComma TInt TComma TInt TComma TInt TComma TInt TComma TCBrace TComma TOBrace TOPar Tlifetime Ttype * Tlifetime TOCro TCCro TCPar TOBrace TString TComma TIdent TComma TCBrace TComma TOBrace TInt TComma TInt TComma TCBrace TComma TInt TComma TInt TComma TInt TComma TInt TComma TCBrace TComma TOBrace TOPar Tlifetime Ttype * Tlifetime TOCro TCCro TCPar TOBrace TString TComma TIdent TComma TCBrace TComma TOBrace TIdent TComma TIdent TComma TCBrace TComma TInt TComma TInt TComma TInt TComma TInt TComma TCBrace TComma TOBrace TCBrace TComma TCBrace TPtVirg Tvis Tlifetime Ttcons TIdent TIdent TOCro TCCro = TOBrace TOBrace TOPar Tlifetime Ttype * Tlifetime TOCro TCCro TCPar TOBrace TString TComma TIdent TComma TCBrace TComma TOBrace TIdent TComma TIdent TComma TCBrace TComma TInt TComma TInt TComma TInt TComma TInt TComma TCBrace TComma TOBrace TOPar Tlifetime Ttype * Tlifetime TOCro TCCro TCPar TOBrace TString TComma TIdent TComma TCBrace TComma TOBrace TIdent TComma TIdent TComma TCBrace TComma TInt TComma TInt TComma TInt TComma TInt TComma TCBrace TComma TOBrace TOPar Tlifetime Ttype * Tlifetime TOCro TCCro TCPar TOBrace TString TComma TString TComma TString TComma TString TComma TString TComma TString TComma TIdent TComma TCBrace TComma TOBrace TIdent TComma TInt TComma TCBrace TComma TInt TComma TInt TComma TInt TComma TInt TComma TCBrace TComma TOBrace TOPar Tlifetime Ttype * Tlifetime TOCro TCCro TCPar TOBrace TString TComma TIdent TComma TCBrace TComma TOBrace TIdent TComma TIdent TComma TCBrace TComma TInt TComma TInt TComma TInt TComma TInt TComma TCBrace TComma TOBrace TOPar Tlifetime Ttype * Tlifetime TOCro TCCro TCPar TOBrace TString TComma TIdent TComma TCBrace TComma TOBrace TInt TComma TInt TComma TCBrace TComma TInt TComma TInt TComma TInt TComma TInt TComma TCBrace TComma TOBrace TOPar Tlifetime Ttype * Tlifetime TOCro TCCro TCPar TOBrace TString TComma TIdent TComma TCBrace TComma TOBrace TIdent TComma TIdent TComma TCBrace TComma TInt TComma TInt TComma TInt TComma TInt TComma TCBrace TComma TOBrace TCBrace TComma TCBrace TPtVirg
dm thin fix crash by initializing thin devices refcount and completion earlier commit dm thin do not allow thin device activation while pool is suspended delayed the initialization of a new thin devices refcount and completion until after this new thin was added to the pools active_thins list and the pool lock is released this opens a race with a worker thread that walks the list and calls noticing that the refcount goes to __number__ and calling complete freezing up the system and giving the oops below kernel bug unable to handle kernel null pointer dereference at null kernel ip __address__ kernel call trace kernel __address__ kernel __address__ kernel __address__ dm_thin_pool kernel __address__ dm_thin_pool kernel __address__ kernel __address__ kernel __address__ kernel __address__ kernel __address__ kernel __address__ kernel __address__ kernel __address__ set the thin devices initial refcount and initialize the completion before adding it to the pools active_thins list in thin_ctr	drivers md dm-thin TIdent TOPar & TIdent TPtrOp TIdent TComma TInt TCPar TPtVirg TIdent TOPar & TIdent TPtrOp TIdent TCPar TPtVirg TIdent TOPar & TIdent TPtrOp TIdent TComma TInt TCPar TPtVirg TIdent TOPar & TIdent TPtrOp TIdent TCPar TPtVirg
apple_gmux use acpi_video_unregister_backlight instead of acpi_video_unregister acpi_video_unregister not only unregisters the acpi-video backlight interface but also unregisters the acpi video bus event listener causing brightness hotkey presses to no longer generate keypress events the unregistering of the acpi video bus event listener usually is undesirable which by itself is a good reason to switch to acpi_video_unregister_backlight another problem with using acpi_video_unregister rather then using acpi_video_unregister_backlight is that on systems with an intel video opregion most systems whether or not the acpi video bus event listener actually gets unregistered depends on module load ordering scenario a __number__ gets loaded does not do acpi_video_register as there is an intel opregion __number__ gets loaded calls acpi_video_register which registers both the listener and the acpi backlight interface __number__ gets loaded calls acpi_video_unregister causing both the listener and the acpi backlight interface to unregister scenario b __number__ gets loaded does not do acpi_video_register as there is an intel opregion __number__ gets loaded calls acpi_video_dmi_promote_vendor calls acpi_video_unregister which is a nop since acpi_video_register has not yet been called __number__ gets loaded calls acpi_video_register which registers the listener but does not register the acpi backlight interface due to the call to the preciding call to acpi_video_dmi_promote_vendor always loads first as both other modules depend on it so we end up with or without an acpi video bus event listener depending on module load ordering not good switching to using acpi_video_unregister_backlight means that independ of ordering we will always have an acpi video bus event listener fixing this note that this commit means that systems without an intel video opregion and systems which were hitting scenario a wrt module load ordering are now getting an acpi video bus event listener while before they were not on some systems this may cause the brightness hotkeys to start generating keypresses while before they were not good while on other systems this may cause the brightness hotkeys to generate multiple keypress events for a single press not so good since on most systems the acpi video bus is the canonical source for brightness events i believe that the latter case will needs to be handled on a case by case basis by filtering out the duplicate keypresses at the other source for them	drivers platform x86 apple-gmux TIdent TOPar TCPar TPtVirg TIdent TOPar TCPar TPtVirg
issue update message only once this is especially annoying on large boxes x86 booting smp configuration node cpus microcode cpu1 microcode updated early to revision date microcode cpu2 microcode updated early to revision date so issue the update message only once grep microcode shows whether every core got updated properly link	arch x86 kernel cpu microcode amd TIdent TOPar TString TComma TIdent TCPar TPtVirg TIdent TOPar TString TComma TIdent TCPar TPtVirg arch x86 kernel cpu microcode intel TIdent TOPar TString TComma TIdent TPtrOp TIdent TDot TIdent TComma TIdent & TInt TComma TIdent >> TInt TComma TOPar TIdent >> TInt TCPar & TInt TCPar TPtVirg Ttype TIdent = TIdent TOPar TCPar TPtVirg TIdent TOPar TString TComma TIdent TComma TIdent TPtrOp TIdent TDot TIdent TComma TIdent & TInt TComma TIdent >> TInt TComma TOPar TIdent >> TInt TCPar & TInt TCPar TPtVirg
fix indexed emulation indexed instructions where the index register such as lfdx are not illegal indexed with update instructions where the index register such as lfdux are invalid and to be consistent with existing math-emu behavior for other invalid instruction forms will signal as illegal	arch powerpc math-emu math TIdent = TOPar Ttype * TCPar TOPar TOPar TIdent TWhy TIdent TPtrOp TIdent TOCro TIdent TCCro TDotDot TInt TCPar + TIdent TPtrOp TIdent TOCro TOPar TIdent >> TInt TCPar & TInt TCCro TCPar TPtVirg Tkwd TOPar TBang TIdent TCPar Tkwd TOPar TOPar TOPar TIdent >> TInt TCPar & TInt TCPar == TIdent TCPar TIdent = TOPar Ttype * TCPar TOPar TIdent TPtrOp TIdent TOCro TOPar TIdent >> TInt TCPar & TInt TCCro TCPar TPtVirg Tkwd TIdent TPtVirg TIdent = TOPar Ttype * TCPar TOPar TIdent TPtrOp TIdent TOCro TIdent TCCro + TIdent TPtrOp TIdent TOCro TOPar TIdent >> TInt TCPar & TInt TCCro TCPar TPtVirg Tkwd TOPar TBang TIdent TCPar Tkwd TIdent TPtVirg TIdent = TOPar Ttype * TCPar TOPar TIdent TPtrOp TIdent TOCro TIdent TCCro + TIdent TPtrOp TIdent TOCro TOPar TIdent >> TInt TCPar & TInt TCCro TCPar TPtVirg TIdent = TOPar Ttype * TCPar TOPar TOPar TIdent TWhy TIdent TPtrOp TIdent TOCro TIdent TCCro TDotDot TInt TCPar + TIdent TPtrOp TIdent TOCro TOPar TIdent >> TInt TCPar & TInt TCCro TCPar TPtVirg
usb when hot reset for usb3 fails try warm reset when a hot reset standard usb port reset fails on a usb __float__ port the host controller transitions to the error state it reports the port link state as inactive sets the link state change flag and if the device disconnects also reports the disconnect and connect change status its also supposed to transition the link state to rxdetect but the nec xhci host does not unfortunately harald found that the combination of the nec and a logilink usb __float__ to sata adapter triggered this issue the usb core would reset the device the port would go into this error state and the device would never be enumerated this combination works under windows but not under linux when a hot reset fails on a usb __float__ port and the link state is reported as inactive fall back to a warm port reset instead harald confirms that with a warm port reset along with all the change bits being correctly cleared the usb __float__ device will successfully enumerate harald also had to add two other patches xhci set change bit when warm reset change is set and usbcore refine warm reset logic to make this setup work since the warm reset refinement patch is not destined for the stable kernels its too big this patch should not be backported either this fixes	drivers usb core hub Tvis Ttype TIdent TOPar Ttcons TIdent * TIdent TComma Ttype TIdent TComma Ttcons TIdent * TIdent TComma Tsign Ttype TIdent TComma TIdent TIdent TCPar TPtVirg Tvis TIdent TIdent TOPar Ttcons TIdent * TIdent TComma TIdent TIdent TCPar Tkwd TIdent TOPar TIdent TPtrOp TIdent TCPar && TOPar TIdent & TIdent TCPar == TIdent TPtVirg Tkwd TOPar TIdent TOPar TIdent TComma TIdent TCPar TCPar Ttype TIdent TPtVirg Tkwd TOPar TOPar TIdent & TIdent TCPar TCPar TIdent TOPar TIdent TPtrOp TIdent TComma TIdent TComma TIdent TCPar TPtVirg Tkwd TOPar TIdent & TIdent TCPar TIdent TOPar TIdent TPtrOp TIdent TComma TIdent TComma TIdent TCPar TPtVirg Tkwd TOPar TIdent & TIdent TCPar TIdent TOPar TIdent TPtrOp TIdent TComma TIdent TComma TIdent TCPar TPtVirg TIdent TOPar TIdent TPtrOp TIdent TComma TString TComma TIdent TCPar TPtVirg TIdent = TIdent TOPar TIdent TComma TIdent TComma TIdent TComma TIdent TComma TIdent TCPar TPtVirg Tkwd TOPar TOPar TIdent & TIdent TCPar TCPar TIdent TOPar TIdent TPtrOp TIdent TComma TIdent TComma TIdent TCPar TPtVirg Tkwd TIdent TPtVirg
iio adc twl4030_madc fix calculation of the temperature sense current the bit mask to read the setting of the constant current source for measuring the ntc voltage was the wrong one since default value is initialized to the lowest level __number__ the difference was probably never noticed in practice	drivers iio adc twl4030-madc TIdent = TOPar TOPar TIdent & TIdent TCPar + TInt TCPar * TInt TPtVirg TIdent = TOPar TOPar TIdent & TIdent TCPar + TInt TCPar * TInt TPtVirg
acpica tables add new mechanism to skip null entries in rsdt and xsdt it is reported that there are buggy bioses in the world ami uses an xsdt compiler for early bioses this compiler will generate xsdt with a null entry the affected bios versions are ami bios f2-f4 original solution on linux is to use an alternative heathy root table instead of the ill one this commit is commit subject acpica back port and refine validation of the xsdt root table this is an example of such xsdt dumped from b85-hd3 ami f3 bios __number__ __number__ signature xsdt extended system description table __number__ __number__ table length __number__ __number__ __number__ revision __number__ __number__ __number__ checksum __number__ __number__ __number__ oem id alaska __number__ __number__ oem table id a m i __number__ __number__ oem revision __number__ __number__ __number__ asl compiler id ami __number__ __number__ asl compiler revision __number__ __number__ __number__ acpi table address __number__ __number__ __number__ __number__ acpi table address __number__ __number__ __number__ __number__ acpi table address __number__ __number__ __number__ __number__ acpi table address __number__ __number__ __number__ __number__ acpi table address __number__ __number__ __number__ __number__ acpi table address __number__ __number__ __number__ __number__ acpi table address __number__ __number__ __number__ __number__ acpi table address __number__ __number__ __number__ acpi table address __number__ __number__ __number__ __number__ acpi table address __number__ __number__ but according to the bug report the xsdt in fact is not broken in the above xsdt acpi table address contains the same value as rsdt the differences can only be seen on the following __number__ entries __number__ the first entry points to a fadt whose revision is __number__ while the first entry in rsdt points to a fadt whose revision is __number__ the fadt dumped from the address indicated by the first entry of xsdt facp __number__ __number__ __number__ __number__ __number__ __number__ __number__ __number__ __number__ __number__ __number__ __number__ the fadt dumped from the address indicated by the first entry of rsdt facp __number__ __number__ __number__ __number__ __number__ __number__ __number__ __number__ __number__ __number__ __number__ __number__ __number__ __number__ the last entry is a null terminator according to the test result the revision __number__ fadt is accessible thus the original solution turns out to be a work around that is preventing the higher revision tables to be used for such platforms they are all x86-64 platforms and should use xsdt and higher revision fadt this patch offers a new solution where a sanity check is performed before installing a table address from xsdt if the entry is null it is simply discarded note that this patch doesnt remove the original solution so for linux kernel this commit is actually a no-op but it allows acpidump to be working on such platforms by doing so we allow another easy revertable commit to enable this feature so that when that commit is reverted the useful sanity check will not be affected lv zheng references references	drivers acpi acpica tbutils TIdent = TIdent TOPar TIdent TComma TIdent TCPar TPtVirg Tkwd TOPar TBang TIdent TCPar Tkwd TIdent TPtVirg TIdent = TIdent TOPar TIdent TComma TIdent TComma TIdent TComma TIdent TComma & TIdent TCPar TPtVirg TIdent = TIdent TOPar TIdent TOPar TIdent TComma TIdent TCPar TComma TIdent TComma TIdent TComma TIdent TComma & TIdent TCPar TPtVirg TIdent TDotDot TIdent += TIdent TPtVirg tools power acpi os_specific service_layers oslinuxtbl Tkwd TOPar TBang TIdent TCPar Tkwd TPtVirg Tkwd TOPar TBang TIdent TCPar Tkwd TPtVirg
input i8042 i8042_flush fix for a full __number__ buffer when __number__ internal data buffer is full the driver erroneously decides that the controller is not present i8042_flush returns the number of flushed bytes which is in __number__ i8042_buffer_size range inclusive therefore i8042_flush has no way to indicate an error moreover i8042_controller_check takes initially full buffer i8042_flush returned i8042_buffer_size as a sign of absence of the controller lets change i8042 to return instead and make sure we do not return error prematurely	drivers input serio i8042 Ttype TIdent = TInt TPtVirg Ttype TIdent = TInt TPtVirg Ttype TIdent = TInt TPtVirg Tkwd TOPar TOPar TIdent = TIdent TOPar TCPar TCPar & TIdent TCPar Tkwd TOPar TIdent ++ < TIdent TCPar TIdent TOPar TInt TCPar TPtVirg TIdent = TIdent TOPar TCPar TPtVirg TIdent TOPar TString TComma TIdent TComma TIdent & TIdent TWhy TString TDotDot TString TCPar TPtVirg TIdent = - TIdent TPtVirg Tkwd TPtVirg Tkwd TOPar TOPar TOPar TIdent = TIdent TOPar TCPar TCPar & TIdent TCPar && TOPar TIdent < TIdent TCPar TCPar TIdent TOPar TInt TCPar TPtVirg TIdent = TIdent TOPar TCPar TPtVirg TIdent ++ TPtVirg TIdent TOPar TString TComma TIdent TComma TIdent & TIdent TWhy TString TDotDot TString TCPar TPtVirg Tkwd TIdent TPtVirg Tkwd TIdent TPtVirg Tkwd TOPar TIdent TOPar TCPar TCPar Tkwd TOPar TIdent TOPar TCPar == TIdent TCPar
quirk the pipe a quirk in the modeset state checker if we always force the pipe a to on we cant use the hw state to decide whether it should be on hence quirk the quirk the problem is that tracks the state of the entire display pipe including planes encoders and all but our hw state readout simply looks at the pipe but with the pipe a quirk we force-enable that together with its pll to fix that mismatch we have two options quirk the checked state to match what our sw tracking states if the pipe a quirk is in effect improve the hw state readout to not get fooled by the pipe a quirk since we already have similar state clamping in assert_pipe ive opted for the first variant also note that we dont really loose any state checking individual pieces of the abstract crtc pipe are checked in the functions with the various checks we have and the hw state check code doesnt check anything if the pipe is off anyway v2 pimp commit message after discussion with chris and only apply the quirk for the quirk if were checking pipe a otherwise well miss state checking for pipe b on i830m v3 make the code comment consistent with the improved commit message too chris bugzilla reported-and-tested-by v1	drivers gpu drm i915 intel_display Tkwd TOPar TIdent TPtrOp TIdent == TIdent && TIdent TPtrOp TIdent & TIdent TCPar TIdent = TIdent TPtrOp TIdent TPtVirg
drivers net cpsw fix crash while accessing second slave ethernet interface when cpsws number of slave is set to __number__ in device tree and while accessing second slave ndev and priv in cpsw_tx_interrupt there is a kernel crash this is due to cpsw_get_slave_priv not verifying number of slaves while retriving netdev priv and returns a invalid memory region fixing the issue by introducing number of slave check in cpsw_get_slave_priv and cpsw_get_slave_ndev __float__ unable to handle kernel paging request at virtual address __float__ pgd __float__ __number__ __float__ internal error oops __number__ smp arm __float__ modules linked in __float__ cpu __number__ pid __number__ comm udhcpc tainted g w __float__ hardware name generic am43 flattened device tree __float__ task ti __float__ pc is at __float__ lr is at __float__ pc lr psr __number__ __float__ sp ip fp __number__ __float__ r10 r9 r8 __number__ __float__ r7 __number__ r6 r5 r4 __float__ r3 r2 __number__ r1 r0 __number__ __float__ flags nzcv irqs off fiqs on mode svc_32 isa arm segment user __float__ control table dac __number__ __float__ process udhcpc pid __number__ stack limit __float__ stack to __number__ __float__ __number__ __number__ __float__ __number__ __number__ __float__ __number__ __float__ __number__ __number__ __number__ __float__ __number__ __float__ __address__ __number__ __number__ __float__ __number__ __number__ __float__ __number__ __address__ __number__ __number__ __float__ __number__ __number__ __number__ __number__ __float__ __number__ __number__ __number__ __number__ __number__ __number__ __float__ __number__ __number__ __number__ __number__ __float__ __number__ __number__ __number__ __float__ __number__ __float__ __number__ __number__ __number__ __float__ __number__ __number__ __number__ __address__ __float__ __number__ __number__ __number__ __number__ __float__ __number__ __number__ __number__ __number__ __number__ __float__ __number__ __number__ __number__ __float__ __number__ __number__ __number__ __number__ __number__ __number__ __float__ __number__ __number__ __number__ __number__ __number__ __number__ __number__ __address__ __float__ __number__ __number__ __number__ __number__ __number__ __number__ __number__ __number__ __float__ __number__ __number__ __number__ __number__ __float__ __number__ __number__ __number__ __number__ __number__ __float__ __number__ __number__ __number__ __number__ __number__ __number__ __float__ __number__ __number__ __number__ __number__ __number__ __number__ __address__ __float__ __address__ __address__ __address__ __float__ __number__ __number__ __number__ __number__ __number__ __number__ __float__ __number__ __number__ __number__ __number__ __float__ __number__ __number__ __number__ __number__ __number__ __float__ __number__ __number__ __number__ __number__ __float__ __number__ __number__ __address__ __number__ __number__ __number__ __float__ __number__ __number__ __number__ __float__ cpsw_tx_interrupt from __float__ handle_irq_event_percpu from __float__ handle_irq_event from __float__ handle_fasteoi_irq from __float__ generic_handle_irq from __float__ __handle_domain_irq from __float__ gic_handle_irq from __float__ exception stack0xed3ffcb0 to __float__ __number__ __number__ __float__ __number__ __number__ __float__ __number__ __address__ __float__ __irq_svc from __float__ _raw_spin_unlock_irqrestore from __float__ cpdma_check_free_tx_desc from __float__ cpsw_ndo_start_xmit from __float__ dev_hard_start_xmit from __float__ sch_direct_xmit from __float__ __dev_queue_xmit from __float__ packet_sendmsg from __float__ sock_sendmsg from __float__ sys_sendto from __float__ code __number__ __number__ __float__ end trace __float__ kernel panic not syncing fatal exception in interrupt __float__ end kernel panic not syncing fatal exception in interrupt	drivers net ethernet ti cpsw TDefine TIdent TOPar TIdent TComma TIdent TCPar TOPar TOPar TIdent < TIdent TPtrOp TIdent TDot TIdent TCPar TWhy TIdent TPtrOp TIdent TOCro TIdent TCCro TDot TIdent TDotDot TIdent TCPar TDefine TIdent TOPar TIdent TComma TIdent TCPar TOPar TIdent TPtrOp TIdent TOCro TIdent TCCro TDot TIdent TCPar TDefine TIdent TOPar TIdent TComma TIdent TCPar TOPar TOPar TOPar TIdent < TIdent TPtrOp TIdent TDot TIdent TCPar && TOPar TIdent TPtrOp TIdent TOCro TIdent TCCro TDot TIdent TCPar TCPar TWhy TIdent TOPar TIdent TPtrOp TIdent TOCro TIdent TCCro TDot TIdent TCPar TDotDot TIdent TCPar TDefine TIdent TOPar TIdent TComma TIdent TCPar TOPar TOPar TIdent TPtrOp TIdent TOCro TIdent TCCro TDot TIdent TCPar TWhy TIdent TOPar TIdent TPtrOp TIdent TOCro TIdent TCCro TDot TIdent TCPar TDotDot TIdent TCPar
