staging wilc1000 restore wilc_spi_dev variable a recent change to wilc1000 accidentally deleted an important variable so we now get a build error when the spi mode is selected error wilc_spi_dev undefined this partially reverts the broken commit to put the variable back	drivers staging wilc1000 linux_wlan_spi Ttcons TIdent * TIdent TPtVirg
media nuvoton-cir fix setting ioport base address at least on zotac ci321 acpi provides an ioport range for the wake up part but accessing these ioports has no effect instead the ioport base address is set to another value already in my case and accessing this ioport range works therefore set a new ioport base address only if the current ioport base address is __number__ register reset default the need to use the existing base address instead of trying to set an own one doesnt seem to be limited to this specific device as other drivers like do it the same way this change was successfully tested on the mentioned device and the change should be generic enough to not break the driver for other chips however due to lack of appropriate hardware i wasnt able to test this version	drivers media rc nuvoton-cir Tvis Ttype TIdent TOPar Ttcons TIdent * TIdent TComma Tsign Ttype * TIdent TCPar Tsign Ttype TIdent TPtVirg TIdent = TIdent TOPar TIdent TComma TIdent TCPar << TInt TPtVirg TIdent |= TIdent TOPar TIdent TComma TIdent TCPar TPtVirg Tkwd TOPar TIdent TCPar * TIdent = TIdent TPtVirg TIdent TOPar TIdent TComma * TIdent >> TInt TComma TIdent TCPar TPtVirg TIdent TOPar TIdent TComma * TIdent & TInt TComma TIdent TCPar TPtVirg TIdent TOPar TIdent TComma & TIdent TPtrOp TIdent TCPar TPtVirg TIdent TOPar TIdent TComma TIdent TPtrOp TIdent >> TInt TComma TIdent TCPar TPtVirg TIdent TOPar TIdent TComma TIdent TPtrOp TIdent & TInt TComma TIdent TCPar TPtVirg TIdent TOPar TIdent TComma & TIdent TPtrOp TIdent TCPar TPtVirg TIdent TOPar TIdent TComma TIdent TPtrOp TIdent >> TInt TComma TIdent TCPar TPtVirg TIdent TOPar TIdent TComma TIdent TPtrOp TIdent & TInt TComma TIdent TCPar TPtVirg
tracing function fix trace header to follow context-info option the header display of function tracer does not follow the context-info option so field names are displayed even if this option is off added check for trace_iter_context_info trace_flags with following commands echo function echo __number__ cat trace this is what it looked like before tracer function task-pid timestamp function add_preempt_count rcu_note_context_switch this is what it looks like now tracer function _raw_spin_unlock_irqrestore link	kernel trace trace Tkwd TOPar TBang TOPar TIdent & TIdent TCPar TCPar Tkwd TPtVirg
ipv6 drop metadata dst in ip6_route_input the fix in commit is incomplete as now ip6_route_input can be called with non-null dst if its a metadata dst and the reference is leaked drop the reference	net ipv6 route TIdent TOPar TIdent TCPar TPtVirg
nvmx reset rflags register cache during nested vmentry during nested vmentry into vm86 mode a vcpu state is found to be incorrect because rflags does not have vm flag set since it is read from the cache and has l1s value instead of l2s if l0 kvm tries to emulate it but emulation does not work for nvmx and it never should happen anyway fix that by using vmx_set_rflags to set rflags during nested vmentry which takes care of updating register cache	arch x86 kvm vmx TIdent TOPar TIdent TComma TIdent TPtrOp TIdent TCPar TPtVirg TIdent TOPar TIdent TComma TIdent TPtrOp TIdent TCPar TPtVirg
metag perf fix core internal perf channel mux the value written to the perf_icorex or perf_chanx register to select the performance events for the core internal and perf channel events was tmp but tmp was set to config so it would always be __number__ correct it to use config instead of tmp	arch metag kernel perf perf_event TIdent TOPar TOPar TIdent & TInt TCPar TComma TIdent TCPar TPtVirg TIdent TOPar TOPar TIdent & TInt TCPar TComma TIdent TCPar TPtVirg
iio light bh1780 assign a static name using the struct field for naming the light sensor is a bad idea when booting from the pure device tree this is null and that causes the device not to have the name property in sysfs and that in turn confuses the lsiio command to stop listing devices so instead of using the device use the hard string bh1780 which works just fine	drivers iio light bh1780 TIdent TPtrOp TIdent = TString TPtVirg TIdent TPtrOp TIdent = TIdent TPtrOp TIdent TPtVirg
spi lp-8841 return correct error code from probe the spi_lp8841_rtc_probe function misses an initialization of the return code when it fails to get its memory resource as gcc notices in function spi_lp8841_rtc_probe error ret may be used uninitialized in this function this changes the code to propagate the error from devm_ioremap_resource	drivers spi spi-lp8841-rtc TIdent TPtrOp TIdent = TIdent TOPar & TIdent TPtrOp TIdent TComma TIdent TCPar TPtVirg TIdent = TIdent TOPar TIdent TPtrOp TIdent TCPar TPtVirg Tkwd TOPar TIdent TCPar TIdent TPtrOp TIdent = TIdent TOPar & TIdent TPtrOp TIdent TComma TIdent TCPar TPtVirg Tkwd TOPar TIdent TOPar TIdent TPtrOp TIdent TCPar TCPar
bluetooth check for matching irk when looking for paired le devices if were given an rpa when checking whether were paired or not we should consult the local rpa storage whether theres a matching irk this we we ensure that hci_bdaddr_is_paired gives the right result even when trying to pair a second time with the same device with an rpa	net bluetooth hci_core Ttcons TIdent * TIdent TPtVirg TIdent = TIdent TOPar TIdent TComma TIdent TComma TIdent TCPar TPtVirg Tkwd TOPar TIdent TCPar TIdent = & TIdent TPtrOp TIdent TPtVirg TIdent = TIdent TPtrOp TIdent TPtVirg
hso fix deadlock when receiving bursts of data when the module sends bursts of data sometimes a deadlock happens in the hso driver when the tty buffer doesnt get the chance to be flushed quickly enough remove the endless while loop in function put_rxbuf_data which is called by the urb completion handler if there isnt enough room in the tty buffer discards all the data received in the urb	drivers net usb hso TIdent TIdent TPtVirg Ttype TIdent TPtVirg Ttype TIdent = TInt TPtVirg Ttype TIdent TPtVirg Tkwd TOPar TIdent && TIdent TOPar TIdent TComma & TIdent TPtrOp TIdent TCPar TCPar TIdent TOPar TIdent TCPar TPtVirg Tkwd - TInt TPtVirg TIdent = TIdent TPtrOp TIdent - TIdent TPtrOp TIdent TPtVirg TIdent = TIdent TOPar & TIdent TPtrOp TIdent TComma TIdent TPtrOp TIdent TCPar TPtVirg Tkwd TOPar TIdent >= TIdent TPtrOp TIdent TCPar TIdent TOPar & TIdent TPtrOp TIdent TComma TIdent TPtrOp TIdent TComma TIdent TPtrOp TIdent TCPar TPtVirg Tkwd TOPar TIdent TCPar Tkwd TOPar TIdent && TIdent TOPar TIdent TComma & TIdent TPtrOp TIdent TCPar TCPar TIdent TOPar TIdent TCPar TPtVirg Tkwd - TInt TPtVirg TIdent = TIdent TOPar & TIdent TPtrOp TIdent TComma TIdent TPtrOp TIdent + TIdent TPtrOp TIdent TComma TIdent TCPar TPtVirg TIdent TPtrOp TIdent += TIdent TPtVirg TIdent -= TIdent TPtVirg TIdent TOPar & TIdent TPtrOp TIdent TPtrOp TIdent TPtrOp TIdent TComma TString TComma TIdent TPtrOp TIdent TCPar TPtVirg TIdent TPtrOp TIdent TOCro TIdent TOPar TIdent TComma TIdent TCPar TCCro = TInt TPtVirg Tkwd TInt TPtVirg Tkwd TOPar TIdent == TInt TCPar TIdent TPtrOp TIdent = TInt TPtVirg TIdent TPtrOp TIdent TOCro TIdent TOPar TIdent TComma TIdent TCPar TCCro = TInt TPtVirg Tkwd TIdent TPtVirg TIdent TPtrOp TIdent = TInt TPtVirg
cifs override unmappable incoming uids and gids the cifs protocol has a space for uids and gids while linux only supports a space today instead of silently truncating cifs ids replace cifs ids that do not fit in the linux id space with the default uid and gids for the cifs mount	fs cifs inode TIdent TPtrOp TIdent = TIdent TPtrOp TIdent TPtVirg Tkwd TOPar TBang TOPar TIdent TPtrOp TIdent & TIdent TCPar TCPar TIdent TIdent = TIdent TOPar TIdent TPtrOp TIdent TCPar TPtVirg Tkwd TOPar TIdent < TOPar TOPar TIdent TCPar - TInt TCPar TCPar TIdent TPtrOp TIdent = TIdent TPtVirg TIdent TPtrOp TIdent = TIdent TPtrOp TIdent TPtVirg Tkwd TOPar TBang TOPar TIdent TPtrOp TIdent & TIdent TCPar TCPar TIdent TIdent = TIdent TOPar TIdent TPtrOp TIdent TCPar TPtVirg Tkwd TOPar TIdent < TOPar TOPar TIdent TCPar - TInt TCPar TCPar TIdent TPtrOp TIdent = TIdent TPtVirg Tkwd TOPar TIdent TPtrOp TIdent & TIdent TCPar TIdent TPtrOp TIdent = TIdent TPtrOp TIdent TPtVirg TIdent TPtrOp TIdent = TIdent TOPar TIdent TPtrOp TIdent TCPar TPtVirg Tkwd TOPar TIdent TPtrOp TIdent & TIdent TCPar TIdent TPtrOp TIdent = TIdent TPtrOp TIdent TPtVirg TIdent TPtrOp TIdent = TIdent TOPar TIdent TPtrOp TIdent TCPar TPtVirg
net allow dcbnl to use other namespaces besides init_net allow dcb and net namespace to work together this is useful if you have containers that are bound to phys interfaces that want to also manage their dcb attributes the net namespace is taken from of the netlink skb	net dcb dcbnl Tkwd TOPar TBang TIdent TOPar TIdent TComma & TIdent TCPar TCPar Tkwd - TIdent TPtVirg TIdent = TIdent TOPar TIdent TComma TIdent TOPar TIdent TOCro TIdent TCCro TCPar TCPar TPtVirg TIdent = TIdent TOPar & TIdent TComma TIdent TOPar TIdent TOCro TIdent TCCro TCPar TCPar TPtVirg TIdent = TIdent TOPar TIdent TComma TIdent TComma TIdent TCPar TPtVirg TIdent = TIdent TOPar TIdent TComma & TIdent TComma TIdent TCPar TPtVirg
bgmac register napi before the device napi should get registered before the netdev and not after	drivers net ethernet broadcom bgmac TIdent TOPar TIdent TComma & TIdent TPtrOp TIdent TComma TIdent TComma TIdent TCPar TPtVirg TIdent TOPar TIdent TComma & TIdent TPtrOp TIdent TComma TIdent TComma TIdent TCPar TPtVirg TIdent TOPar & TIdent TPtrOp TIdent TCPar TPtVirg TIdent TOPar & TIdent TPtrOp TIdent TCPar TPtVirg
fix the pause_time test pause_time is unsigned so it cant be less than zero the bug means that we allow invalid pause-times	drivers net ethernet freescale fman fman_dtsec Tkwd TOPar TIdent <= TInt TCPar Tkwd TOPar TIdent < TInt && TIdent <= TInt TCPar
power twl4030_madc_battery add missing module_alias without module_alias twl4030_madc_battery wont get loaded automatically	drivers power twl4030_madc_battery TIdent TOPar TString TCPar TPtVirg
clk atlas7 fix pll missed divide nr in fraction mode pll vco frequency is given by fvco fref __number__ nf nr in integer-n mode or by fvco fref ssn nr in spread spectrum fractional-n mode thus fix the missing part of nr	drivers clk sirf clk-atlas7 TIdent TOPar TIdent TComma TIdent TCPar TPtVirg
nfsd41 error out when client sets maxreq_sz or maxresp_sz too small according to rfc5661 if the client selects a value for ca_maxresponsesize such that a replier on a channel could never send a server should return nfs4err_toosmall in the create_session reply so error out when the client sets a maxreq_sz less than the minimum possible sequence request size or sets a maxresp_sz less than the minimum possible sequence reply size	fs nfsd nfs4state TDefine TIdent TOPar TOPar TInt * TInt + TInt + TInt + TIdent TOPar TIdent TCPar + TInt TCPar * Tkwd TOPar TIdent TCPar TCPar TDefine TIdent TOPar TOPar TInt + TInt + TInt + TInt + TIdent TOPar TIdent TCPar + TInt TCPar * Tkwd TOPar TIdent TCPar TCPar Tvis TIdent TIdent TOPar Ttcons TIdent TIdent TCPar Tkwd TIdent TDot TIdent < TIdent || TIdent TDot TIdent < TIdent TPtVirg TIdent = TIdent TPtVirg Tkwd TOPar TIdent TOPar TIdent TPtrOp TIdent TCPar TCPar Tkwd TIdent TPtVirg
asoc ad193x-spi fixup ad193x_spi_id table ad1939 is missed from the table so add it ad1936 and ad1937 are controlled by i2c interface so remove them	sound soc codecs ad193x-spi Tvis Tlifetime Ttcons TIdent TIdent TOCro TCCro = TOBrace TOBrace TString TComma TIdent TComma TCBrace TComma TOBrace TString TComma TIdent TComma TCBrace TComma TOBrace TString TComma TIdent TComma TCBrace TComma TOBrace TString TComma TIdent TComma TCBrace TComma TOBrace TString TComma TIdent TComma TCBrace TComma TOBrace TString TComma TIdent TComma TCBrace TComma TOBrace TCBrace TComma TCBrace TPtVirg
fix rtnl notifications on iface deletion the function geneve_dev_create_fb only used by ovs never calls rtnl_configure_link the consequence is that is never set to rtnl_link_initialized during the deletion phase the function rollback_registered_many sends a rtm_dellink only if is set to rtnl_link_initialized	drivers net geneve TIdent = TIdent TOPar TIdent TComma TIdent TCPar TPtVirg Tkwd TOPar TIdent < TInt TCPar Tkwd TIdent TPtVirg
isdn icn buffer overflow in icn_command this buffer over was detected using static analysis icn_command error format string overflow buf_size __number__ length __number__ the calculation for the length of the string is off because it assumes that the dial buffer holds a __number__ character string but actually it is at most __number__ characters and nul i have removed the dial buffer because it isnt needed the maximum length of the string is actually __number__ characters and a nul i have made the cbuf array large enough to hold it and changed the sprintf to an snprintf as a further safety enhancement	drivers isdn icn icn Ttype TIdent TOCro TInt TCCro TPtVirg Ttype TIdent TOCro TInt TCCro TPtVirg Ttype TIdent TOCro TInt TCCro TPtVirg TIdent TOPar TIdent TComma Tkwd TOPar TIdent TCPar TComma TString TComma TOPar Ttype TCPar TOPar TIdent + TInt TCPar TComma TIdent TComma TIdent TComma TIdent TPtrOp TIdent TDot TIdent TDot TIdent TComma TIdent TPtrOp TIdent TDot TIdent TDot TIdent TComma TIdent TPtrOp TIdent TDot TIdent TDot TIdent TCPar TPtVirg TIdent TOPar TIdent TComma TIdent TCPar TPtVirg TIdent TOPar TIdent TComma TString TComma TOPar Ttype TCPar TOPar TIdent + TInt TCPar TComma TIdent TComma TIdent TComma TIdent TPtrOp TIdent TDot TIdent TDot TIdent TComma TIdent TPtrOp TIdent TDot TIdent TDot TIdent TComma TIdent TPtrOp TIdent TDot TIdent TDot TIdent TCPar TPtVirg
gma500 fix leak of uncached page this was reported a long time ago and i apologize to whoever it was that reported it as ive lost the original report	drivers gpu drm gma500 psb_drv TIdent TOPar TIdent TPtrOp TIdent TComma TInt TCPar TPtVirg
xfs xfs_filemap_pmd_fault treats read faults as write faults the code initially committed didnt have the same checks for write faults as the dax_pmd_fault code and hence treats all faults as write faults we can get read faults through this path because they is no pmd_mkwrite path for write faults similar to the normal page fault path hence we need to ensure that we only do updates on write faults and freeze protection is unnecessary for read faults	fs xfs xfs_file Tkwd TOPar TIdent & TIdent TCPar TIdent TOPar TIdent TPtrOp TIdent TCPar TPtVirg TIdent TOPar TIdent TPtrOp TIdent TCPar TPtVirg TIdent TOPar TIdent TPtrOp TIdent TCPar TPtVirg TIdent TOPar TIdent TPtrOp TIdent TCPar TPtVirg Tkwd TOPar TIdent & TIdent TCPar TIdent TOPar TIdent TPtrOp TIdent TCPar TPtVirg TIdent TOPar TIdent TPtrOp TIdent TCPar TPtVirg
ath10k apply chainmask settings to vdev on creation it appears it takes more than just setting the hardwares chainmask to make things work well without this patch a vdev would only use rates when chainmask was set to setting the nss number of spatial streams on the vdev helps the firmwares rate-control algorithm work properly	drivers net wireless ath ath10k mac Tvis Ttype TIdent TOPar Ttcons TIdent * TIdent TComma TIdent TIdent TComma Tlifetime Ttype * TIdent TCPar Tkwd TOPar TIdent == TInt || TIdent == TInt || TIdent == TInt || TIdent == TInt || TIdent == TInt TCPar Tkwd TPtVirg TIdent TOPar TIdent TComma TString TComma TIdent TComma TIdent TCPar TPtVirg TIdent TOPar TIdent TComma TIdent TComma TString TCPar TPtVirg TIdent TOPar TIdent TComma TIdent TComma TString TCPar TPtVirg Tvis TIdent TIdent TOPar TIdent TIdent TCPar Tkwd TOPar TOPar TIdent & TInt TCPar == TInt TCPar Tkwd TInt TPtVirg Tkwd TOPar TOPar TIdent & TInt TCPar == TInt TCPar Tkwd TInt TPtVirg Tkwd TOPar TOPar TIdent & TInt TCPar == TInt TCPar Tkwd TInt TPtVirg Tkwd TInt TPtVirg Tkwd TOPar TIdent TPtrOp TIdent TCPar TIdent TIdent = TIdent TOPar TIdent TPtrOp TIdent TCPar TPtVirg TIdent = TIdent TPtrOp TIdent TDot TIdent TPtrOp TIdent TPtVirg TIdent = TIdent TOPar TIdent TComma TIdent TPtrOp TIdent TComma TIdent TComma TIdent TCPar TPtVirg Tkwd TOPar TIdent TCPar TIdent TOPar TIdent TComma TString TComma TIdent TPtrOp TIdent TComma TIdent TPtrOp TIdent TComma TIdent TComma TIdent TCPar TPtVirg Tkwd TIdent TPtVirg
tty fix data race on race on buffer data happens when newly committed data is picked up by an old flush work in the following scenario __tty_buffer_request_room does a plain write of no barriers were executed before that at this point flush_to_ldisc reads this new value of commit and reads buffer data no barriers in between the committed buffer data is not necessary visible to flush_to_ldisc similar bug happens when tty_schedule_flip commits data update commit with smp_store_release and read commit with smp_load_acquire as it is commit that signals data readiness this is orthogonal to the existing synchronization on which is required to not dismiss a buffer with unconsumed data the data race was found with kernelthreadsanitizer ktsan	drivers tty tty_buffer TIdent TOPar & TIdent TPtrOp TIdent TComma TIdent TPtrOp TIdent TCPar TPtVirg TIdent TPtrOp TIdent = TIdent TPtrOp TIdent TPtVirg TIdent TOPar & TIdent TPtrOp TIdent TPtrOp TIdent TComma TIdent TPtrOp TIdent TPtrOp TIdent TCPar TPtVirg TIdent TPtrOp TIdent TPtrOp TIdent = TIdent TPtrOp TIdent TPtrOp TIdent TPtVirg TIdent = TIdent TOPar & TIdent TPtrOp TIdent TCPar - TIdent TPtrOp TIdent TPtVirg TIdent = TIdent TPtrOp TIdent - TIdent TPtrOp TIdent TPtVirg
powerpc fix size of st_nlink on commit e57f93cc53b7 powerpc get rid of nlink_t uses switch to explicitly-sized type changed the size of st_nlink on ppc64 from a long to a short resulting in boot failures	arch powerpc include asm stat Tsign Ttype TIdent TPtVirg Tsign Ttype TIdent TPtVirg
pci add dell studio __number__ to blacklist the dell studio __number__ also doesnt suspend correctly when crs is enabled details at	arch x86 pci acpi Tvis Tlifetime Ttcons TIdent TIdent TOCro TCCro = TOBrace TOBrace TDot TIdent = TIdent TComma TDot TIdent = TString TComma TDot TIdent = TOBrace TIdent TOPar TIdent TComma TString TCPar TComma TIdent TOPar TIdent TComma TString TCPar TComma TCBrace TComma TCBrace TComma TOBrace TDot TIdent = TIdent TComma TDot TIdent = TString TComma TDot TIdent = TOBrace TIdent TOPar TIdent TComma TString TCPar TComma TCBrace TComma TCBrace TComma TOBrace TDot TIdent = TIdent TComma TDot TIdent = TString TComma TDot TIdent = TOBrace TIdent TOPar TIdent TComma TString TCPar TComma TIdent TOPar TIdent TComma TString TCPar TComma TIdent TOPar TIdent TComma TString TCPar TComma TCBrace TComma TCBrace TComma TOBrace TDot TIdent = TIdent TComma TDot TIdent = TString TComma TDot TIdent = TOBrace TIdent TOPar TIdent TComma TString TCPar TComma TIdent TOPar TIdent TComma TString TCPar TComma TIdent TOPar TIdent TComma TString TCPar TComma TCBrace TComma TCBrace TComma TOBrace TCBrace TComma TCBrace TPtVirg
fix address range for asynchronous stack git commit dc7ee00d4771 s390 lowcore stack pointer offsets introduced a regression in regard to s390_backtrace the stack pointer for the asynchronous stack in the lowcore now has an additional offset applied this offset needs to be taken into account in the calculation for the low and high address for the stack this bug was already partially fixed with commit fix address ranges for asynchronous and panic stack this patch fixes it also for the oprofile code	arch s390 oprofile backtrace Tsign Ttype TIdent TComma TIdent TPtVirg Tsign Ttype TIdent TPtVirg TIdent = TIdent + Tkwd TOPar Ttcons TIdent TCPar TPtVirg TIdent = TIdent TOPar & TIdent TComma TIdent TComma TIdent TDot TIdent + TIdent - TIdent TComma TIdent TDot TIdent + TIdent TCPar TPtVirg TIdent = TIdent TOPar & TIdent TComma TIdent TComma TIdent TDot TIdent - TIdent TComma TIdent TDot TIdent TCPar TPtVirg
use the correct destructor for freeing requests on error after allocating from the slab cache we then need to free the request back into the slab cache upon error and not call kfree as that leads to eventual memory corruption fixes regression from commit efab6d8dd158fdccbe6a030f89fbf9ca0a9564e4 author chris wilson chris-wilson.co.uk date tue apr __number__ __number__ use a separate slab for requests	drivers gpu drm i915 i915_gem Tkwd TOPar TIdent TCPar Tkwd TIdent TPtVirg Tkwd TOPar TIdent TCPar TIdent TOPar TIdent TCPar TPtVirg Tkwd TIdent TPtVirg Tkwd TOPar TIdent TCPar Tkwd TIdent TPtVirg Tkwd TOPar TIdent TCPar TIdent TOPar TIdent TCPar TPtVirg Tkwd TIdent TPtVirg TIdent TDotDot TIdent TOPar TIdent TPtrOp TIdent TComma TIdent TCPar TPtVirg TIdent TOPar TIdent TPtrOp TIdent TComma TIdent TCPar TPtVirg Tkwd TIdent TPtVirg
btrfs device_replace fix deadlock for nocow case commit cb7ab02156e4 cause a following deadlock found by thread1 is commiting transaction which is blocked at btrfs_scrub_pause thread2 is calling btrfs_file_aio_write which has held inodes and commit transactionblocked because thread1 is committing transaction thread3 is copy_nocow_page worker which will also try to hold inode so thread3 will wait thread1 finished thread4 is waiting pending workers finished which will wait thread3 finished so the problem is like this deadlock happens we fix it by letting thread1 go firstly which means we wont block transaction commit while we are waiting pending workers finished	fs btrfs scrub TIdent TOPar & TIdent TPtrOp TIdent TCPar TPtVirg TIdent TOPar & TIdent TPtrOp TIdent TCPar TPtVirg TIdent TOPar & TIdent TPtrOp TIdent TDot TIdent TComma TInt TCPar TPtVirg TIdent TOPar & TIdent TPtrOp TIdent TDot TIdent TComma TInt TCPar TPtVirg TIdent TOPar & TIdent TPtrOp TIdent TCPar TPtVirg TIdent TOPar TIdent TCPar TPtVirg TIdent TOPar & TIdent TPtrOp TIdent TCPar TPtVirg TIdent TOPar & TIdent TPtrOp TIdent TCPar TPtVirg TIdent TOPar & TIdent TPtrOp TIdent TCPar TPtVirg TIdent TOPar TIdent TCPar TPtVirg
drivers net cpsw fix broken loop condition in switch mode drivers net cpsw fix buggy loop condition accidentally fixed a loop comparison in too many places while fixing a real bug it was correct to fix the dual_emac mode section since there i is used as an index into which is a __number__ based array however the other two changes which are only used in switch mode are wrong since there i is actually the ale port number and port __number__ is the host port while port __number__ and up are the slave ports putting the loop condition back in the switch mode section fixes it a comment has been added to point out the intent clearly to avoid future confusion also a comment is fixed that said the opposite of what was actually happening	drivers net ethernet ti cpsw Tkwd TOPar TIdent = TInt TPtVirg TIdent <= TIdent TPtrOp TIdent TDot TIdent TPtVirg TIdent ++ TCPar Tkwd TOPar TIdent = TInt TPtVirg TIdent < TIdent TPtrOp TIdent TDot TIdent TPtVirg TIdent ++ TCPar Tkwd TOPar TIdent = TInt TPtVirg TIdent <= TIdent TPtrOp TIdent TDot TIdent TPtVirg TIdent ++ TCPar Tkwd TOPar TIdent = TInt TPtVirg TIdent < TIdent TPtrOp TIdent TDot TIdent TPtVirg TIdent ++ TCPar
dmaengine at_xdmac fix false condition for memset_sg transfers the code was not in agreement with the comments	drivers dma at_xdmac Tkwd TOPar TOPar TIdent == TOPar TIdent - TInt TCPar TCPar && TIdent TOPar TIdent TCPar == TIdent TOPar TIdent TCPar TCPar Tkwd TOPar TOPar TIdent == TOPar TIdent - TInt TCPar TCPar && TIdent TOPar TIdent TCPar == TIdent TOPar TIdent TCPar TCPar
scsi_transport_sas remove check for sas expander when querying ids dell server backplanes can report ids without an expander present this patch allows the ids to be propagaged to	drivers scsi scsi_transport_sas Tkwd TOPar TIdent TOPar TIdent TCPar TCPar Tkwd - TIdent TPtVirg Tkwd TOPar TIdent TOPar TIdent TCPar TCPar Tkwd - TIdent TPtVirg
fix divwu instruction opcode currently divwu stands for divw opcode __number__ divwu d6 divw use the divw opcode for divwu	arch powerpc include asm ppc-opcode TDefine TIdent TInt TDefine TIdent TInt
btrfs fix crash when mounting raid5 btrfs with missing disks the reproducer is d1 d2 d3 d2 d3 mount d1 __float__ cut here __float__ kernel bug at __float__ rip __address__ __address__ __float__ call trace __float__ __address__ __float__ __address__ __float__ __address__ __float__ __address__ __float__ __address__ __float__ __address__ __float__ __address__ __float__ __address__ __float__ __address__ __float__ __address__ __float__ __address__ __float__ __address__ __float__ __address__ __float__ __address__ its because that we miscalculate so that it doesnt reach maximum of tolerable errors while it should have	fs btrfs raid56 Tkwd TOPar TIdent TPtrOp TIdent == TIdent || TIdent TPtrOp TIdent == TIdent TCPar TIdent TOPar & TIdent TPtrOp TIdent TPtrOp TIdent TCPar TPtVirg Tkwd TOPar TIdent TPtrOp TIdent == TIdent || TIdent TPtrOp TIdent == TIdent TCPar
l2tp fix race in l2tp_recv_dequeue misha labjuk reported panics occurring in l2tp_recv_dequeue if we release we must not keep a dangling pointer tmp since another thread could manipulate reorder_q instead we must restart the scan at beginning of list	net l2tp l2tp_core TIdent TDotDot TIdent TOPar & TIdent TPtrOp TIdent TDot TIdent TCPar TPtVirg Tkwd TIdent TPtVirg TIdent TOPar & TIdent TPtrOp TIdent TDot TIdent TCPar TPtVirg
aio fix use-after-free in aio_migratepage dmitry vyukov managed to trigger a case where aio_migratepage can cause a use-after-free during teardown of the aio ring buffers mapping this turns out to be caused by access to the ioctxs ring_pages via the migratepage operation which was not being protected by any locks during ioctx freeing use the address_spaces private_lock to protect use and updates of the mappings private_data and make ioctx teardown unlink the ioctx from the address space	fs aio Tvis Ttype TIdent TOPar Ttcons TIdent * TIdent TCPar Ttcons TIdent * TIdent = TIdent TPtrOp TIdent TPtVirg Tkwd TOPar TIdent TCPar TIdent TOPar TIdent TPtrOp TIdent TComma TInt TCPar TPtVirg TIdent TOPar & TIdent TPtrOp TIdent TPtrOp TIdent TPtrOp TIdent TCPar TPtVirg TIdent TPtrOp TIdent TPtrOp TIdent TPtrOp TIdent = TIdent TPtVirg TIdent TPtrOp TIdent = TIdent TPtVirg TIdent TOPar & TIdent TPtrOp TIdent TPtrOp TIdent TPtrOp TIdent TCPar TPtVirg TIdent TOPar TIdent TCPar TPtVirg Ttcons TIdent * TIdent = TIdent TPtrOp TIdent TPtVirg TIdent TOPar TIdent TCPar TPtVirg Tkwd TOPar TIdent TCPar TIdent TOPar TIdent TPtrOp TIdent TComma TInt TCPar TPtVirg TIdent TOPar TIdent TCPar TPtVirg TIdent TPtrOp TIdent = TIdent TPtVirg Ttcons TIdent * TIdent TPtVirg Ttcons TIdent * TIdent = TIdent TPtrOp TIdent TPtVirg Tsign TIdent = TIdent TPtrOp TIdent TPtVirg TIdent TOPar & TIdent TPtrOp TIdent TCPar TPtVirg TIdent = TIdent TPtrOp TIdent TPtVirg Tkwd TOPar TIdent TCPar TIdent TIdent TPtVirg TIdent TOPar & TIdent TPtrOp TIdent TComma TIdent TCPar TPtVirg TIdent TOPar TIdent TComma TIdent TCPar TPtVirg TIdent = TIdent TPtrOp TIdent TPtVirg Tkwd TOPar TIdent < TOPar TIdent TCPar TIdent TPtrOp TIdent TCPar TIdent TPtrOp TIdent TOCro TIdent TCCro = TIdent TPtVirg TIdent TOPar & TIdent TPtrOp TIdent TComma TIdent TCPar TPtVirg TIdent = - TIdent TPtVirg TIdent TOPar & TIdent TPtrOp TIdent TCPar TPtVirg TIdent TOPar & TIdent TPtrOp TIdent TComma TIdent TCPar TPtVirg TIdent TOPar TIdent TComma TIdent TCPar TPtVirg TIdent TPtrOp TIdent TOCro TIdent TCCro = TIdent TPtVirg TIdent TOPar & TIdent TPtrOp TIdent TComma TIdent TCPar TPtVirg TIdent TOPar TIdent TCPar TPtVirg Tkwd TOPar TIdent TPtrOp TIdent TCPar TIdent TOPar TIdent TPtrOp TIdent TCPar TPtVirg
usb dwc3 enable when setconfiguration received as per databook bits should be set after receiving setconfiguration command	drivers usb dwc3 ep0 TIdent TIdent TPtVirg TIdent = TIdent TOPar TIdent TPtrOp TIdent TComma TIdent TCPar TPtVirg TIdent |= TOPar TIdent | TIdent TCPar TPtVirg TIdent TOPar TIdent TPtrOp TIdent TComma TIdent TComma TIdent TCPar TPtVirg drivers usb dwc3 gadget TIdent |= TOPar TIdent | TIdent TCPar TPtVirg
fix null pointer dereference on cpu hotplug after disabling irqs in the current kernel percpu variable vector_irq is not always cleared when a cpu is offlined if the cpu that has the disabled irqs in vector_irq is hotplugged again __setup_vector_irq hits invalid irq vector and may crash this bug can be reproduced as following echo __number__ modprobe some_driver_using_interrupts uncleared echo __number__ kernel may crash to fix this problem this patch clears vector_irq in __fixup_irqs when the cpu is offlined this also reverts commit f6175f5bfb4c which partially fixes this bug by clearing vector in __clear_irq_vector but in environments with iommu irq remapper it could fail because doesnt contain offlined cpus with this patch the fix in __clear_irq_vector can be reverted because every vector_irq is already cleared in __fixup_irqs on offlined cpus link	arch x86 kernel apic io_apic TIdent TOPar TIdent TComma TIdent TPtrOp TIdent TComma TIdent TCPar TIdent TOPar TIdent TComma TIdent TPtrOp TIdent TCPar TIdent TOPar TIdent TComma TIdent TPtrOp TIdent TComma TIdent TCPar TIdent TOPar TIdent TComma TIdent TPtrOp TIdent TCPar arch x86 kernel irq TIdent TOPar TIdent TOCro TIdent TCCro TComma - TInt TCPar TPtVirg
x86 fix boot failures on older amd cpus people with old amd chips are getting hung boots because commit bcb80e53877c x86 microcode amd add microcode revision to moved the microcode detection too early into early_init_amd at that point we are early in the booth that the exception tables havent even been set up yet so the whole rdmsr_safemsr_amd64_patch_level doesnt actually work if the rdmsr does a gp fault due to non-existant msr register on older cpus we cant fix it up yet and the boot fails fix it by simply moving the code to a slightly later point in the boot init_amd instead of early_init_amd since the kernel itself doesnt even really care about the microcode patchlevel at this point or really ever its made available to user space in and updated if you do a microcode load	arch x86 kernel cpu amd TIdent TIdent TPtVirg TIdent TOPar TIdent TComma & TIdent TPtrOp TIdent TComma & TIdent TCPar TPtVirg TIdent TIdent TPtVirg TIdent TOPar TIdent TComma & TIdent TPtrOp TIdent TComma & TIdent TCPar TPtVirg
l2tp fix refcount leak in l2tp_ip sockets the l2tp_ip socket close handler does not update the module refcount correctly which prevents module unload after the first bind call on an l2tpv3 ip encapulation socket	net l2tp l2tp_ip TIdent TOPar TIdent TCPar TPtVirg TIdent TOPar & TIdent TPtrOp TIdent TCPar TPtVirg
fix panel fitter setting if need to enable the panel fitter the crtc timings have to be programmed according to the panels native fixed mode this isnt the case atm since after the encoder changes adjusted_mode to fixed mode the timing fields of adjusted_mode will stay at their original non-native values that the user passed in this results in a corrupted output one exception is when we have a second pass of computing encoder configs due to bandwidth limitation since then well set fields to the fixed mode values set in the first pass so in this case things will work out fix this by updating the fields when we set the fixed panel mode this regression has been introduced in commit date sun jul __number__ __number__ clean up crtc timings computation	drivers gpu drm i915 intel_panel TIdent TOPar TIdent TComma TInt TCPar TPtVirg
ubifs fix power cut emulation for mtdram the power cut emulation did not work correctly because we corrupted more than one max unit in the buffer and then wrote the entire buffer this lead to recovery errors because ubifs complained about corrupted free space and this was easily reproducible on mtdram because max write size is very small there __number__ bytes and we could easily have a buffer corrupt __number__ bytes there and then write the entire buffer the fix is to corrupt max write size bytes at most and write only up to the last corrupted max write size chunk not the entire buffer	fs ubifs debug Tvis Ttype TIdent TOPar Tlifetime Ttcons TIdent * TIdent TComma Tlifetime Ttype * TIdent TComma Tsign Ttype TIdent TCPar Tvis Ttype TIdent TOPar Tlifetime Ttype * TIdent TComma Tsign Ttype TIdent TCPar TIdent = TIdent TOPar TIdent TComma TIdent TOPar TIdent TComma TIdent TPtrOp TIdent TCPar TCPar TPtVirg Tkwd TOPar TIdent TOPar TInt TComma TInt TCPar TCPar TIdent = TIdent TOPar TCPar % TOPar TIdent - TIdent + TInt TCPar TPtVirg TIdent = TIdent TPtVirg TIdent TOPar TString TComma TIdent TComma TIdent - TInt TComma TIdent TWhy TString TDotDot TString TCPar TPtVirg Tkwd TOPar TIdent < TIdent TCPar TIdent TOPar TString TComma TIdent TComma TIdent - TInt TComma TIdent TWhy TString TDotDot TString TCPar TPtVirg Tkwd TIdent TPtVirg TIdent = TIdent TOPar TIdent TComma TIdent TComma TIdent TCPar TPtVirg TIdent TOPar TString TComma TIdent TComma TIdent TComma TIdent TCPar TPtVirg TIdent TOPar TIdent TComma TIdent TCPar TPtVirg
rtlwifi rtl8188ee missing curly braces in handle_branch1 from the indenting it seems like the read_next_pair was supposed to be inside the while loop	drivers net wireless rtlwifi rtl8188ee phy Tkwd TOPar TIdent != TInt && TIdent != TInt && TIdent != TInt && TIdent < TIdent - TInt TCPar Tkwd TOPar TIdent != TInt && TIdent != TInt && TIdent != TInt && TIdent < TIdent - TInt TCPar
fix an endian bug in atom table parsing	drivers gpu drm radeon radeon_atombios TIdent TPtrOp TIdent = TOPar TIdent TCPar TOPar TOPar TIdent TOPar TIdent TPtrOp TIdent TCPar - TIdent TOPar TIdent TComma TIdent TCPar TCPar / TIdent TCPar TPtVirg TIdent TPtrOp TIdent = TOPar TIdent TCPar TOPar TOPar TIdent TPtrOp TIdent - TIdent TOPar TIdent TComma TIdent TCPar TCPar / TIdent TCPar TPtVirg
iser-target fix reject cm event use-after-free oops this patch fixes a bug in iser-target code where the reject cm event handler code currently performs a isert_put_conn for the final put while iscsi_np process context is still blocked in isert_get_login_rx once isert_get_login_rx is awoking due to login timeout iscsi_np process context will attempt to invoke iscsi_target_login_sess_out to cleanup iscsi_conn as expected and calls isert_wait_conn isert_free_conn which triggers the use-after-free oops to address this bug move the kref_get_unless_zero call from isert_connected_handler into isert_connect_request immediately preceeding isert_rdma_accept to ensure the cm handler cleanup paths and isert_free_conn are always operating with two refs	drivers infiniband ulp isert ib_isert Tkwd TOPar TBang TIdent TOPar & TIdent TPtrOp TIdent TCPar TCPar TIdent TOPar TString TComma TIdent TCPar TPtVirg Tkwd TIdent TPtVirg Tkwd TOPar TBang TIdent TOPar & TIdent TPtrOp TIdent TCPar TCPar TIdent TOPar TString TComma TIdent TCPar TPtVirg Tkwd TPtVirg
udf dont corrupt unalloc spacetable when writing it for a udf filesystem configured with an unallocated space table a filesystem operation that triggers an update to the table results in on-disk corruption that prevents remounting udf_read_tagged tag version __number__ block __number__ for example __number__ create a filesystem mkudffs __number__ mount it mount __number__ create a file echo no corruption please __number__ umount umount __number__ attempt remount mount this appears to be a longstanding bug caused by zero-initialization of the unallocated space entry block buffer and only partial repopulation of required fields before writing to disk commit udf fix unalloc space handling in udf_update_inode addressed one such field but several others are required	fs udf inode TIdent = Tkwd TOPar Ttcons TIdent TCPar TPtVirg TIdent TPtrOp TIdent TDot TIdent = TIdent TOPar TIdent TPtrOp TIdent TDot TIdent TCPar TPtVirg TIdent = Tkwd TOPar Ttcons TIdent TCPar + TIdent TPtrOp TIdent - Tkwd TOPar Ttcons TIdent TCPar TPtVirg TIdent TPtrOp TIdent TDot TIdent = TIdent TOPar TIdent TCPar TPtVirg TIdent TPtrOp TIdent TDot TIdent = TIdent TOPar TIdent TOPar TInt TComma TOPar Ttype * TCPar TIdent + Tkwd TOPar Ttcons TIdent TCPar TComma TIdent TCPar TCPar TPtVirg TIdent TPtrOp TIdent TDot TIdent = TIdent TOPar & TIdent TPtrOp TIdent TCPar TPtVirg Tkwd TIdent TPtVirg Tkwd TIdent TPtVirg TIdent TDotDot Tkwd TOPar TIdent TPtrOp TIdent TCPar TOBrace TIdent TPtrOp TIdent TDot TIdent = TIdent TOPar TInt TCPar TPtVirg TIdent TPtrOp TIdent TDot TIdent = TIdent TOPar TInt TCPar TPtVirg TIdent TPtrOp TIdent TDot TIdent = TIdent TOPar TInt TCPar TPtVirg TCBrace Tkwd TOBrace TIdent TPtrOp TIdent TDot TIdent = TIdent TOPar TInt TCPar TPtVirg TIdent TPtrOp TIdent TDot TIdent = TIdent TOPar TInt TCPar TPtVirg TCBrace Tkwd TOPar TIdent TPtrOp TIdent TCPar TIdent TPtrOp TIdent TDot TIdent = TIdent TPtVirg Tkwd TOPar TIdent TOPar TIdent TPtrOp TIdent TCPar TCPar Tkwd TOPar TIdent TOPar TIdent TPtrOp TIdent TCPar TCPar TIdent TDotDot TIdent TOPar TIdent TCPar TPtVirg
arm64 kvm vgic-v3 prevent the guest from messing with icc_sre_el1 both our gic emulations are strict in the sense that we either emulate a gicv2 or a gicv3 and not a gicv3 with gicv2 legacy support but when running on a gicv3 host we still allow the guest to tinker with the icc_sre_el1 register during its time slice it can switch sre off observe that it is off and yet on the next world switch find the sre bit to be set again not very nice an obvious solution is to always trap accesses to icc_sre_el1 by clearing and to let the handler return the programmed value on a read or ignore the write that way the guest can always observe that our gicv3 is only	arch arm64 kvm hyp vgic-v3-sr TIdent TOPar TIdent TOPar TIdent TCPar & TTilde TIdent TComma TIdent TCPar TPtVirg Tkwd TOPar TBang TIdent TPtrOp TIdent TCPar TIdent TOPar TIdent TOPar TIdent TCPar & TTilde TIdent TComma TIdent TCPar TPtVirg
crush allow crush rules to set retries counts to __number__ these two fields are misnomers they are counts reflects commit f17caba8ae0cad7b6f8f35e53e5f73b444696835	net ceph crush mapper Tkwd TOPar TIdent TPtrOp TIdent >= TInt TCPar Tkwd TOPar TIdent TPtrOp TIdent > TInt TCPar Tkwd TOPar TIdent TPtrOp TIdent >= TInt TCPar Tkwd TOPar TIdent TPtrOp TIdent > TInt TCPar
md faulty use disk_stack_limits in block do not artificially constrain max_sectors for stacking drivers max_sectors defaults to uint_max md faulty wasnt using disk_stack_limits so inherited this large value as well this triggered a bug in xfs when stressed over md_faulty when a very large bio_alloc failed that was on an older kernel and i cant reproduce exactly the same thing upstream but i think the fix is appropriate in any case thanks to mike snitzer for pointing out the problem	drivers md faulty TIdent TOPar TIdent TComma TIdent TCPar TIdent TOPar TIdent TComma TIdent TCPar TIdent TOPar TIdent TPtrOp TIdent TComma TIdent TPtrOp TIdent TComma TIdent TPtrOp TIdent << TInt TCPar TPtVirg
add px quirk for asus k53tk seems to have problems turning the dgpu bug	drivers gpu drm radeon radeon_device Tvis Ttcons TIdent TIdent TOCro TCCro = TOBrace TOBrace TIdent TComma TInt TComma TInt TComma TInt TComma TIdent TComma TCBrace TComma TOBrace TIdent TComma TInt TComma TInt TComma TInt TComma TIdent TComma TCBrace TComma TOBrace TIdent TComma TInt TComma TInt TComma TInt TComma TIdent TComma TCBrace TComma TOBrace TIdent TComma TInt TComma TIdent TComma TInt TComma TIdent TComma TCBrace TComma TOBrace TInt TComma TInt TComma TInt TComma TInt TComma TInt TComma TCBrace TComma TCBrace TPtVirg
dmaengine at_xdmac fix missing spin_unlock lock taken when entering the function but unlock missing before it returns	drivers dma at_xdmac TIdent TOPar & TIdent TPtrOp TIdent TCPar TPtVirg
kvm s390 fix hang vcpu regression commit kvm s390 optimize round trip time in request handling introduced a regression this regression was seen with cpu hotplug in the guest and switching between __number__ or __number__ cpus this will the ibs control via synced request whenever we make a synced request we first set the bit and then block the vcpu the handler on the other hand unblocks itself processes by clearing them and unblocks itself once again now if the requester sleeps between setting of and blocking the handler will clear the bit and try to unblock itself although no bit is set when the requester wakes up it blocks the vcpu and we have a blocked vcpu without requests solution is to always unset the block bit	arch s390 kvm kvm-s390 Tkwd TOPar TBang TIdent TPtrOp TIdent TCPar Tkwd TInt TPtVirg Tkwd TOPar TBang TIdent TPtrOp TIdent TCPar Tkwd TInt TPtVirg
random fix handing of arch_get_random_long in get_random_bytes if there is an architecture-specific random number generator we use it to acquire randomness one long at a time we should put these random words into consecutive words in the result buffer not just overwrite the first word again and again link	drivers char random TIdent TOPar TIdent TComma & TIdent TComma TIdent TCPar TPtVirg TIdent TOPar TIdent TComma & TIdent TComma TIdent TCPar TPtVirg
ext4 fix ext4 mismerge back in january duplicate caused afaics by mismerge in	fs ext4 ioctl TIdent TOPar TIdent TPtrOp TIdent TDot TIdent TCPar TPtVirg
btrfs gfp_nofs does not gfp_highmem masking highmem out of nofs does not make sense	fs btrfs delayed-inode TIdent = TIdent TOPar TIdent TCPar TPtVirg TIdent = TIdent TOPar TIdent & TTilde TIdent TCPar TPtVirg fs btrfs disk-io TIdent = TIdent TOPar TIdent TCPar TPtVirg TIdent = TIdent TOPar TIdent & TTilde TIdent TCPar TPtVirg fs btrfs extent_io TIdent = TIdent TOPar TIdent TCPar TPtVirg TIdent = TIdent TOPar TIdent & TTilde TIdent TCPar TPtVirg TIdent = TIdent TOPar TIdent TCPar TPtVirg TIdent = TIdent TOPar TIdent & TTilde TIdent TCPar TPtVirg
alsa hda correct aamix output paths the output paths including aamix should be parsed only for the first output the surround paths including aamix must be wrong since it would mix all streams all channels would be mixed into a single and multiplexed again	sound pci hda hda_generic Tkwd TOPar TBang TIdent && TBang TIdent && TIdent TPtrOp TIdent TCPar Tkwd TOPar TBang TIdent && TIdent > TInt && TIdent TPtrOp TIdent TCPar Tkwd TOPar TBang TIdent && TBang TIdent && TIdent TPtrOp TIdent TCPar Tkwd TOPar TBang TIdent && TIdent > TInt && TIdent TPtrOp TIdent TCPar
dmaengine at_xdmac fix memory leak in interleaved mode in interleaved mode when numf __number__ we have only one descriptor for the transfer but this descriptor has to be added to the descs_list if not when doing remove_xfer the descriptor wont be put back in the free_descs_list	drivers dma at_xdmac TIdent TOPar TIdent TOPar TIdent TCPar TComma TString TComma TIdent TComma TIdent TComma TIdent TCPar TPtVirg TIdent TOPar & TIdent TPtrOp TIdent TComma & TIdent TPtrOp TIdent TCPar TPtVirg
ksm dont fail stable tree lookups if walking over stale stable_nodes the stable_nodes can become stale at any time if the underlying pages gets freed the stable_node gets collected and removed from the stable rbtree if that is detected during the rbtree lookups dont fail the lookup if running into stale stable_nodes just restart the lookup after collecting the stale stable_nodes otherwise the cpu spent in the preparation stage is wasted and the lookup must be repeated at the next loop potentially failing a second time in a second stale stable_node if we dont prune aggressively we delay the merging of the unstable node candidates and at the same time we delay the freeing of the stale stable_nodes keeping stale stable_nodes around wastes memory and it cant provide any benefit	mm ksm Tkwd TOPar TBang TIdent TCPar Tkwd TIdent TPtVirg Tkwd TOPar TBang TIdent TCPar Tkwd TIdent TPtVirg Ttcons TIdent * TIdent TPtVirg Ttcons TIdent * TIdent = TIdent TPtVirg TIdent TDotDot TIdent = TIdent TPtVirg TIdent = TIdent TPtVirg Tkwd TOPar TBang TIdent TCPar Tkwd TIdent TPtVirg Tkwd TOPar TBang TIdent TCPar Tkwd TIdent TPtVirg
issue update message only once this is especially annoying on large boxes x86 booting smp configuration node cpus microcode cpu1 microcode updated early to revision date microcode cpu2 microcode updated early to revision date so issue the update message only once grep microcode shows whether every core got updated properly link	arch x86 kernel cpu microcode amd TIdent TOPar TString TComma TIdent TCPar TPtVirg TIdent TOPar TString TComma TIdent TCPar TPtVirg arch x86 kernel cpu microcode intel TIdent TOPar TString TComma TIdent TPtrOp TIdent TDot TIdent TComma TIdent & TInt TComma TIdent >> TInt TComma TOPar TIdent >> TInt TCPar & TInt TCPar TPtVirg Ttype TIdent = TIdent TOPar TCPar TPtVirg TIdent TOPar TString TComma TIdent TComma TIdent TPtrOp TIdent TDot TIdent TComma TIdent & TInt TComma TIdent >> TInt TComma TOPar TIdent >> TInt TCPar & TInt TCPar TPtVirg
fix indexed emulation indexed instructions where the index register such as lfdx are not illegal indexed with update instructions where the index register such as lfdux are invalid and to be consistent with existing math-emu behavior for other invalid instruction forms will signal as illegal	arch powerpc math-emu math TIdent = TOPar Ttype * TCPar TOPar TOPar TIdent TWhy TIdent TPtrOp TIdent TOCro TIdent TCCro TDotDot TInt TCPar + TIdent TPtrOp TIdent TOCro TOPar TIdent >> TInt TCPar & TInt TCCro TCPar TPtVirg Tkwd TOPar TBang TIdent TCPar Tkwd TOPar TOPar TOPar TIdent >> TInt TCPar & TInt TCPar == TIdent TCPar TIdent = TOPar Ttype * TCPar TOPar TIdent TPtrOp TIdent TOCro TOPar TIdent >> TInt TCPar & TInt TCCro TCPar TPtVirg Tkwd TIdent TPtVirg TIdent = TOPar Ttype * TCPar TOPar TIdent TPtrOp TIdent TOCro TIdent TCCro + TIdent TPtrOp TIdent TOCro TOPar TIdent >> TInt TCPar & TInt TCCro TCPar TPtVirg Tkwd TOPar TBang TIdent TCPar Tkwd TIdent TPtVirg TIdent = TOPar Ttype * TCPar TOPar TIdent TPtrOp TIdent TOCro TIdent TCCro + TIdent TPtrOp TIdent TOCro TOPar TIdent >> TInt TCPar & TInt TCCro TCPar TPtVirg TIdent = TOPar Ttype * TCPar TOPar TOPar TIdent TWhy TIdent TPtrOp TIdent TOCro TIdent TCCro TDotDot TInt TCPar + TIdent TPtrOp TIdent TOCro TOPar TIdent >> TInt TCPar & TInt TCCro TCPar TPtVirg
iio adc twl4030_madc fix calculation of the temperature sense current the bit mask to read the setting of the constant current source for measuring the ntc voltage was the wrong one since default value is initialized to the lowest level __number__ the difference was probably never noticed in practice	drivers iio adc twl4030-madc TIdent = TOPar TOPar TIdent & TIdent TCPar + TInt TCPar * TInt TPtVirg TIdent = TOPar TOPar TIdent & TIdent TCPar + TInt TCPar * TInt TPtVirg
input i8042 i8042_flush fix for a full __number__ buffer when __number__ internal data buffer is full the driver erroneously decides that the controller is not present i8042_flush returns the number of flushed bytes which is in __number__ i8042_buffer_size range inclusive therefore i8042_flush has no way to indicate an error moreover i8042_controller_check takes initially full buffer i8042_flush returned i8042_buffer_size as a sign of absence of the controller lets change i8042 to return instead and make sure we do not return error prematurely	drivers input serio i8042 Ttype TIdent = TInt TPtVirg Ttype TIdent = TInt TPtVirg Ttype TIdent = TInt TPtVirg Tkwd TOPar TOPar TIdent = TIdent TOPar TCPar TCPar & TIdent TCPar Tkwd TOPar TIdent ++ < TIdent TCPar TIdent TOPar TInt TCPar TPtVirg TIdent = TIdent TOPar TCPar TPtVirg TIdent TOPar TString TComma TIdent TComma TIdent & TIdent TWhy TString TDotDot TString TCPar TPtVirg TIdent = - TIdent TPtVirg Tkwd TPtVirg Tkwd TOPar TOPar TOPar TIdent = TIdent TOPar TCPar TCPar & TIdent TCPar && TOPar TIdent < TIdent TCPar TCPar TIdent TOPar TInt TCPar TPtVirg TIdent = TIdent TOPar TCPar TPtVirg TIdent ++ TPtVirg TIdent TOPar TString TComma TIdent TComma TIdent & TIdent TWhy TString TDotDot TString TCPar TPtVirg Tkwd TIdent TPtVirg Tkwd TIdent TPtVirg Tkwd TOPar TIdent TOPar TCPar TCPar Tkwd TOPar TIdent TOPar TCPar == TIdent TCPar
